{"version":3,"file":"mithril-infinite.js","sources":["../src/classes.js","../src/util.js","../src/page.js","../src/placeholder.js","../src/styler.js","../src/css.js","../src/index.js"],"sourcesContent":["\nexport const classes = {\n  scrollView:    \"mithril-infinite__scroll-view\",\n  scrollViewX:   \"mithril-infinite__scroll-view--x\",\n  scrollViewY:   \"mithril-infinite__scroll-view--y\",\n  scrollContent: \"mithril-infinite__scroll-content\",\n  content:       \"mithril-infinite__content\",\n  pages:         \"mithril-infinite__pages\",\n  page:          \"mithril-infinite__page\",\n  pageEven:      \"mithril-infinite__page--even\",\n  pageOdd:       \"mithril-infinite__page--odd\",\n  before:        \"mithril-infinite__before\",\n  after:         \"mithril-infinite__after\"\n};\n","import verge from \"verge\";\nimport { classes } from \"./classes\";\n\nconst LEEWAY = 300;\n\nexport const getElementSize = (el, axis) => {\n  const styles = window.getComputedStyle(el);\n  if (axis === \"x\") {\n    const margin = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    return el.scrollWidth + margin;\n  } else {\n    const margin = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    return el.scrollHeight + margin;\n  }\n};\n\n// el, axis = \"y\", expand = LEEWAY\nexport const isElementInViewport = ({el, axis = \"y\", leeway = LEEWAY}) => {\n  return axis === \"y\"\n    ? verge.inY(el, leeway) || verge.inY(el, -leeway)\n    : axis === \"x\"\n      ? verge.inX(el, leeway) || verge.inX(el, -leeway)\n      : verge.inViewport(el, leeway) || verge.inViewport(el, -leeway);\n};\n\nexport const makeClassName = pageNum => [\n  classes.page,\n  pageNum % 2 === 0 ? classes.pageEven : classes.pageOdd\n].join(\" \");","import m from \"mithril\";\nimport { getElementSize, makeClassName } from \"./util\";\n\nconst getPageData = url => {\n  return m.request({\n    method: \"GET\",\n    url,\n    initialValue: [],\n    background: true\n  });\n};\n\nexport const page = {};\n\npage.controller = (opts = {}) => {\n  const pageNum = opts.pageNum;\n  let content = m.prop([]);\n  if (opts.pageData) {\n    const result = opts.pageData(pageNum);\n    if (result.then) {\n      // A Promise\n      result.then((r) => {\n        content(r);\n      });\n    } else {\n      content = result;\n    }\n  } else if (opts.pageUrl) {\n    const url = opts.pageUrl(pageNum);\n    getPageData(url).then(data => (\n      content(data),\n      m.redraw()\n    ));\n  }\n\n  return {\n    content,\n    // Memoize some properties that do not change\n    className: makeClassName(pageNum),\n    pageTag: opts.pageTag || \"div\"\n  };\n};\n\npage.view = (ctrl, opts = {}) => {\n  const pageId = opts.pageId;\n  const storedPageSize = opts.pageSizes[pageId] || 0;\n\n  // pageSize overrides all measurements on elements here\n  let pageSize = 0;\n  if (opts.pageSize) {\n    pageSize = opts.pageSize(ctrl.content());\n    opts.updatePageSize(pageId, pageSize);\n  }\n  const cssSize = pageSize\n    ? pageSize + \"px\"\n    : !opts.autoSize || (opts.isScrolling && storedPageSize)\n      ? storedPageSize + \"px\"\n      : \"auto\";\n  const processPageData = opts.processPageData || ((content, opts1) =>\n    content\n      ? content.map((data, index) => opts.item(data, opts1, index))\n      : null\n  );\n\n  return m(ctrl.pageTag, {\n    \"data-page\": pageId,\n    class: ctrl.className,\n    style: storedPageSize\n      ? Object.assign(\n        {},\n        opts.axis === \"x\"\n          ? { width: cssSize }\n          : { height: cssSize }\n      )\n      : {},\n    config: pageSize\n      ? null\n      : el => {\n        // always update the natural size\n        const size = getElementSize(el, opts.axis);\n        if (size) {\n          opts.updatePageSize(pageId, size);\n        }\n        if (!storedPageSize) {\n          // this is the very first measurement\n          // make sure we use the first page size by calling the view again\n          setTimeout(m.redraw, 0);\n        }\n      }\n  }, processPageData(ctrl.content(), opts));\n};\n\n\n","import m from \"mithril\";\nimport { makeClassName } from \"./util\";\n\nexport const placeholder = {};\n\nplaceholder.controller = (opts = {}) => {\n  // Memoize some properties that do not change\n  return {\n    className: makeClassName(opts.pageNum)\n  };\n};\n\nplaceholder.view = (ctrl, opts = {}) => {\n  const pageId = opts.pageId;\n  const storedPageSize = opts.pageSizes[pageId] || 0;\n  return m(\"div\", {\n    \"data-page\": pageId,\n    class: ctrl.className,\n    style: Object.assign(\n      {},\n      opts.axis === \"x\"\n        ? { width:  storedPageSize + \"px\" }\n        : { height: storedPageSize + \"px\" }\n    )\n  });\n};\n","import J2c from \"j2c\";\nconst j2c = new J2c();\n\n/*\n * @param id: identifier, used as HTMLElement id for the attached <style></style> element\n * @param styles: list of lists style Objects\n */\nexport const addStyle = (id, ...styles) => {\n  removeStyle(id);\n  const styleEl = document.createElement(\"style\");\n  if (id) {\n    styleEl.setAttribute(\"id\", id);\n  }\n  styles.forEach((styleList) => {\n    // each style returns a list\n    if (Object.keys(styleList).length) {\n      styleList.forEach((style) => {\n        const scoped = { \"@global\": style };\n        const sheet = j2c.sheet(scoped);\n        styleEl.appendChild(document.createTextNode(sheet));\n      });\n    }\n  });\n  document.head.appendChild(styleEl);\n};\n\nconst removeStyle = id => {\n  if (id) {\n    const old = document.getElementById(id);\n    if (old) {\n      old.parentNode.removeChild(old);\n    }\n  }\n};","import { addStyle } from \"./styler\";\nimport { classes } from \"./classes\";\n\nconst styles = [{\n  [\".\" + classes.scrollView]: {\n    \"-webkit-overflow-scrolling\": \"touch\",\n    height: \"100%\",\n\n    [\"&.\" + classes.scrollViewY]: {\n      overflowX: \"hidden\",\n      overflowY: \"auto\",\n      height: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        height: \"100%\"\n      }\n    },\n\n    [\"&.\" + classes.scrollViewX]: {\n      overflowX: \"auto\",\n      overflowY: \"hidden\",\n      width: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        width: \"100%\"\n      }\n    }\n  }\n  // by default unstyled:\n  // mithril-infinite__content\n  // mithril-infinite__pages\n  // mithril-infinite__page\n}];\n\naddStyle(\"mithril-infinite\", styles);\n","import m from \"mithril\";\nimport { classes } from \"./classes\";\nimport { getElementSize, isElementInViewport } from \"./util\";\nimport { page } from \"./page\";\nimport { placeholder } from \"./placeholder\";\nimport \"./css\";\n\nconst SCROLL_WATCH_TIMER = 200;\nconst SEL_PADDING = \"000000\";\n\nconst numToId = pageNum =>\n  SEL_PADDING.substring(0, SEL_PADDING.length - (\"\" + pageNum).length) + pageNum;\n\nconst calculateCurrentPageNum = (scrollAmount, state) => {\n  const pageNumKeys = state.sortedKeys;\n  let acc = state.beforeSize || 0;\n  let currentPageNum = 1;\n  for (let i = 0; i < pageNumKeys.length; i = i + 1) {\n    let pageKey = pageNumKeys[i];\n    if (scrollAmount > acc) {\n      currentPageNum = parseInt(pageKey, 10);\n    }\n    acc += state.pageSizes[pageKey];\n  }\n  return currentPageNum;\n};\n\nconst calculateContentSize = (from, to, state) => {\n  const fromIndex = Math.max(0, from - 1);\n  if (to < fromIndex) {\n    return 0;\n  }\n  const toIndex = to;\n  const pageNumKeys = state.sortedKeys.slice(fromIndex, toIndex);\n  let size = state.beforeSize || 0;\n  size = pageNumKeys.reduce((total, pageKey) => (\n    total += state.pageSizes[pageKey] || 0\n  ), size);\n  size += state.afterSize || 0;\n  return size;\n};\n\nconst isPageInViewport = (page, axis, state, scrollView) => {\n  if (!scrollView) {\n    return false;\n  }\n  const id = numToId(page);\n  const el = scrollView.querySelector(\"[data-page=\\\"\" + id + \"\\\"]\");\n  return isElementInViewport({ el, axis });\n};\n\nconst updatePageSize = ctrl => (pageId, size) => (\n  ctrl.state.pageSizes[pageId] = size,\n  ctrl.state.sortedKeys = Object.keys(ctrl.state.pageSizes).sort()\n);\n\nexport const infinite = {};\n\ninfinite.controller = (opts) => {\n  // Memoize some properties that do not change\n  const whichScroll = opts.axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n  const maxPages = opts.maxPages !== undefined ? opts.maxPages : Number.MAX_VALUE;\n  const autoSize = (opts.autoSize !== undefined && opts.autoSize === false) ? false : true;\n  const scrollThrottle = opts.throttle !== undefined ? opts.throttle * 1000 : SCROLL_WATCH_TIMER;\n  const contentTag = opts.contentTag || \"div\";\n\n  return {\n    state: {\n      pageSizes: {},\n      sortedKeys: [],\n      beforeSize: null,\n      afterSize: null\n    },\n    scrollView: null,\n    isScrolling: false,\n    scrollWatchScrollingStateId: null,\n    scrollWatchUpdateStateId: null,\n    preloadSlots: opts.preloadPages || 1,\n    boundingClientRect: {},\n    currentPageNum: 0,\n    scrollAmount: 0,\n\n    // Memoized\n    whichScroll,\n    maxPages,\n    autoSize,\n    scrollThrottle,\n    contentTag\n  };\n};\n\ninfinite.view = (ctrl, opts) => {\n  const state = ctrl.state;\n  ctrl.scrollAmount = ctrl.scrollView ? ctrl.scrollView[ctrl.whichScroll] : 0;\n  \n  const currentPageNum = opts.currentPage\n    ? parseInt(opts.currentPage, 10)\n    : calculateCurrentPageNum(ctrl.scrollAmount, state);\n\n  if (currentPageNum !== ctrl.currentPageNum && opts.pageChange) {\n    opts.pageChange(currentPageNum);\n  }\n  ctrl.currentPageNum = currentPageNum;\n\n  if (ctrl.scrollView && opts.getDimensions) {\n    opts.getDimensions({\n      scrolled: ctrl.scrollAmount,\n      size: ctrl.contentSize\n    });\n  }\n\n  const minPageNum = opts.from\n    ? parseInt(opts.from, 10)\n    : opts.currentPage\n      ? opts.currentPage\n      : 1;\n  const maxPageNum = opts.to\n    ? parseInt(opts.to, 10)\n    : opts.currentPage\n      ? opts.currentPage\n      : ctrl.maxPages;\n  const pages = [];\n  const prePages = [];\n  for (let i = -ctrl.preloadSlots; i <= ctrl.preloadSlots; i = i + 1) {\n    const pageNum = currentPageNum + i;\n    if (pageNum >= minPageNum && pageNum <= maxPageNum) {\n      pages.push(pageNum);\n    }\n  }\n  for (let pageNum = 1; pageNum < pages[0]; pageNum = pageNum + 1) {\n    prePages.push(pageNum);\n  }\n\n  const classList = [\n    classes.scrollView,\n    opts.axis === \"x\"\n      ? classes.scrollViewX\n      : classes.scrollViewY,\n    opts.class\n  ].join(\" \");\n  ctrl.contentSize = calculateContentSize(1, maxPageNum, state);\n  const isLastPageVisible = maxPageNum\n    ? isPageInViewport(maxPageNum, opts.axis, state, ctrl.scrollView)\n    : true;\n\n  if (ctrl.scrollView) {\n    // in case the screen size was changed, reset preloadSlots\n    const boundingClientRect = ctrl.scrollView.getBoundingClientRect();\n    ctrl.boundingClientRect = ctrl.boundingClientRect || boundingClientRect;\n    if (boundingClientRect.width !== ctrl.boundingClientRect.width\n      || boundingClientRect.height !== ctrl.boundingClientRect.height\n    ) {\n      ctrl.preloadSlots = opts.preloadPages || 1;\n    }\n    ctrl.boundingClientRect = boundingClientRect;\n    // calculate if we have room to load more\n    const maxSlots = opts.maxPreloadPages || Number.MAX_VALUE;\n\n    if (ctrl.contentSize\n      && (ctrl.preloadSlots < pages.length)\n      && (ctrl.preloadSlots <= maxSlots)\n      && (ctrl.contentSize < boundingClientRect.height)\n    ) {\n      ctrl.preloadSlots++;\n      setTimeout(m.redraw, 0);\n    }\n  }\n\n  return m(\"div\", {\n    config: (el, inited, context) => {\n      if (inited) {\n        return;\n      }\n      if (opts.scrollView) {\n        ctrl.scrollView = document.querySelector(opts.scrollView);\n      } else {\n        ctrl.scrollView = el;\n      }\n      ctrl.scrollView.className += \" \" + classList;\n\n      if (opts.setDimensions) {\n        const dimensions = opts.setDimensions();\n        const whichSize = opts.axis === \"x\"\n          ? \"width\"\n          : \"height\";\n        if (dimensions.size > 0) {\n          el.style[whichSize] = dimensions.size + \"px\";\n        }\n        ctrl.scrollView[ctrl.whichScroll] = dimensions.scrolled;\n      }\n\n      const handleScroll = () => {\n        ctrl.isScrolling = true;\n\n        // reset isScrolling state only when scrolling is done\n        clearTimeout(ctrl.scrollWatchScrollingStateId);\n        ctrl.scrollWatchScrollingStateId = setTimeout(() => {\n          ctrl.isScrolling = false;\n          // update pages\n          m.redraw();\n        }, ctrl.scrollThrottle);\n\n        // throttle updates while scrolling\n        if (!ctrl.scrollWatchUpdateStateId) {\n          ctrl.scrollWatchUpdateStateId = setTimeout(() => {\n            // update pages\n            m.redraw();\n            ctrl.scrollWatchUpdateStateId = null;\n          }, ctrl.scrollThrottle);\n        }\n      };\n      ctrl.scrollView.addEventListener(\"scroll\", handleScroll);\n      context.onunload = () => {\n        ctrl.scrollView.removeEventListener(\"scroll\", handleScroll);\n      };\n    }\n  }, m(\"div\", {\n    class: classes.scrollContent,\n    style: !ctrl.autoSize\n      ? {}\n      : Object.assign(\n        {},\n        opts.axis === \"x\"\n          ? { width: ctrl.contentSize + \"px\" }\n          : { height: ctrl.contentSize + \"px\" },\n        opts.contentSize\n          ? opts.axis === \"x\"\n            ? { \"min-width\": opts.contentSize + \"px\" }\n            : { \"min-height\": opts.contentSize + \"px\" }\n          : {}\n    )\n  }, [\n    m(ctrl.contentTag, { class: classes.content }, [\n      opts.before\n        ? m(\"div\", {\n          class: classes.before,\n          config: el => {\n            // always update the natural size\n            const size = getElementSize(el, opts.axis);\n            if (size) {\n              state.beforeSize = size;\n            }\n          }\n        }, opts.before)\n        : null,\n      m(\"div\", { class: classes.pages }, [\n        prePages.map(pageNum => \n          m(placeholder, Object.assign(\n            {},\n            opts,\n            {\n              pageNum,\n              pageId: numToId(pageNum),\n              pageSizes: state.pageSizes\n            }\n          ))\n        ),\n        pages.map(pageNum =>\n          m(page, Object.assign(\n            {},\n            opts,\n            {\n              pageNum,\n              pageId: numToId(pageNum),\n              isScrolling: ctrl.isScrolling,\n              pageSizes: state.pageSizes,\n              updatePageSize: updatePageSize(ctrl),\n              autoSize: ctrl.autoSize\n            }\n          ))\n        )\n      ]),\n      // only show \"after\" when content is available\n      opts.after && ctrl.contentSize\n        ? m(\"div\", {\n          class: classes.after,\n          style: {\n            // visually hide this element until the last page is into view\n            // to prevent flashes of after content when scrolling fast\n            visibility: isLastPageVisible ? \"visible\" : \"hidden\"\n          },\n          config: el => {\n            // always update the natural size\n            const size = getElementSize(el, opts.axis);\n            if (size) {\n              state.afterSize = size;\n            }\n          }\n        }, opts.after)\n        : null\n    ])\n  ]));\n};\n\ninfinite.isElementInViewport = isElementInViewport;\n\n"],"names":["classes","LEEWAY","getElementSize","el","axis","styles","window","getComputedStyle","margin","parseFloat","marginLeft","marginRight","scrollWidth","marginTop","marginBottom","scrollHeight","isElementInViewport","leeway","verge","inY","inX","inViewport","makeClassName","page","pageNum","pageEven","pageOdd","join","getPageData","m","request","controller","opts","content","prop","pageData","result","then","r","pageUrl","url","data","redraw","pageTag","view","ctrl","pageId","storedPageSize","pageSizes","pageSize","updatePageSize","cssSize","autoSize","isScrolling","processPageData","opts1","map","index","item","className","babelHelpers.extends","width","height","size","placeholder","j2c","J2c","addStyle","id","styleEl","document","createElement","setAttribute","forEach","styleList","Object","keys","length","style","scoped","@global","sheet","appendChild","createTextNode","head","removeStyle","old","getElementById","parentNode","removeChild","scrollView","scrollViewY","scrollContent","scrollViewX","SCROLL_WATCH_TIMER","SEL_PADDING","numToId","substring","calculateCurrentPageNum","scrollAmount","state","pageNumKeys","sortedKeys","acc","beforeSize","currentPageNum","i","pageKey","parseInt","calculateContentSize","from","to","fromIndex","Math","max","toIndex","slice","reduce","total","afterSize","isPageInViewport","querySelector","sort","infinite","whichScroll","maxPages","undefined","Number","MAX_VALUE","scrollThrottle","throttle","contentTag","preloadPages","currentPage","pageChange","getDimensions","contentSize","minPageNum","maxPageNum","pages","prePages","preloadSlots","push","classList","class","isLastPageVisible","boundingClientRect","getBoundingClientRect","maxSlots","maxPreloadPages","inited","context","setDimensions","dimensions","whichSize","scrolled","handleScroll","scrollWatchScrollingStateId","setTimeout","scrollWatchUpdateStateId","addEventListener","onunload","removeEventListener","min-width","min-height","before","after"],"mappings":"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"}