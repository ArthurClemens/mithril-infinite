{"version":3,"file":"mithril-infinite.js","sources":["../src/classes.js","../src/util.js","../src/page.js","../src/placeholder.js","../src/styler.js","../src/css.js","../src/index.js"],"sourcesContent":["\nexport const classes = {\n  scrollView:    \"mithril-infinite__scroll-view\",\n  scrollViewX:   \"mithril-infinite__scroll-view--x\",\n  scrollViewY:   \"mithril-infinite__scroll-view--y\",\n  scrollContent: \"mithril-infinite__scroll-content\",\n  content:       \"mithril-infinite__content\",\n  pages:         \"mithril-infinite__pages\",\n  page:          \"mithril-infinite__page\",\n  pageEven:      \"mithril-infinite__page--even\",\n  pageOdd:       \"mithril-infinite__page--odd\",\n  before:        \"mithril-infinite__before\",\n  after:         \"mithril-infinite__after\"\n};\n","import verge from \"verge\";\nimport { classes } from \"./classes\";\n\nconst LEEWAY = 300;\n\nexport const getElementSize = (el, axis) => {\n  const styles = window.getComputedStyle(el);\n  if (axis === \"x\") {\n    const margin = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    return el.scrollWidth + margin;\n  } else {\n    const margin = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    return el.scrollHeight + margin;\n  }\n};\n\n// el, axis = \"y\", expand = LEEWAY\nexport const isElementInViewport = ({el, axis = \"y\", leeway = LEEWAY}) => {\n  return axis === \"y\"\n    ? verge.inY(el, leeway) || verge.inY(el, -leeway)\n    : axis === \"x\"\n      ? verge.inX(el, leeway) || verge.inX(el, -leeway)\n      : verge.inViewport(el, leeway) || verge.inViewport(el, -leeway);\n};\n\nexport const makeClassName = pageNum => [\n  classes.page,\n  pageNum % 2 === 0 ? classes.pageEven : classes.pageOdd\n].join(\" \");","import m from \"mithril\";\nimport { getElementSize, makeClassName } from \"./util\";\n\nconst getPageData = url => {\n  return m.request({\n    method: \"GET\",\n    url,\n    initialValue: [],\n    background: true\n  });\n};\n\nexport const page = {};\n\npage.controller = (opts = {}) => {\n  const pageNum = opts.pageNum;\n  let content = m.prop([]);\n  if (opts.pageData) {\n    const result = opts.pageData(pageNum);\n    if (result.then) {\n      // A Promise\n      result.then((r) => {\n        content(r);\n        m.redraw();\n      });\n    } else {\n      content = result;\n    }\n  } else if (opts.pageUrl) {\n    const url = opts.pageUrl(pageNum);\n    getPageData(url).then(data => (\n      content(data),\n      m.redraw()\n    ));\n  }\n\n  return {\n    content,\n    // Memoize some properties that do not change\n    className: makeClassName(pageNum),\n    pageTag: opts.pageTag || \"div\"\n  };\n};\n\npage.view = (ctrl, opts = {}) => {\n  const pageId = opts.pageId;\n  const storedPageSize = opts.pageSizes[pageId] || 0;\n\n  // pageSize overrides all measurements on elements here\n  let pageSize = 0;\n  if (opts.pageSize) {\n    pageSize = opts.pageSize(ctrl.content());\n    opts.updatePageSize(pageId, pageSize);\n  }\n  const cssSize = pageSize\n    ? pageSize + \"px\"\n    : !opts.autoSize || (opts.isScrolling && storedPageSize)\n      ? storedPageSize + \"px\"\n      : \"auto\";\n  const processPageData = opts.processPageData || ((content, opts1) =>\n    content\n      ? content.map((data, index) => opts.item(data, opts1, index))\n      : null\n  );\n\n  return m(ctrl.pageTag, {\n    \"data-page\": pageId,\n    class: ctrl.className,\n    style: storedPageSize\n      ? Object.assign(\n        {},\n        opts.axis === \"x\"\n          ? { width: cssSize }\n          : { height: cssSize }\n      )\n      : {},\n    config: pageSize\n      ? null\n      : el => {\n        // always update the natural size\n        const size = getElementSize(el, opts.axis);\n        if (size) {\n          opts.updatePageSize(pageId, size);\n        }\n        if (!storedPageSize) {\n          // this is the very first measurement\n          // make sure we use the first page size by calling the view again\n          setTimeout(m.redraw, 0);\n        }\n      }\n  }, processPageData(ctrl.content(), opts));\n};\n\n\n","import m from \"mithril\";\nimport { makeClassName } from \"./util\";\n\nexport const placeholder = {};\n\nplaceholder.controller = (opts = {}) => {\n  // Memoize some properties that do not change\n  return {\n    className: makeClassName(opts.pageNum)\n  };\n};\n\nplaceholder.view = (ctrl, opts = {}) => {\n  const pageId = opts.pageId;\n  const storedPageSize = opts.pageSizes[pageId] || 0;\n  return m(\"div\", {\n    \"data-page\": pageId,\n    class: ctrl.className,\n    style: Object.assign(\n      {},\n      opts.axis === \"x\"\n        ? { width:  storedPageSize + \"px\" }\n        : { height: storedPageSize + \"px\" }\n    )\n  });\n};\n","import J2c from \"j2c\";\nconst j2c = new J2c();\n\n/*\n * @param id: identifier, used as HTMLElement id for the attached <style></style> element\n * @param styles: list of lists style Objects\n */\nexport const addStyle = (id, ...styles) => {\n  removeStyle(id);\n  const styleEl = document.createElement(\"style\");\n  if (id) {\n    styleEl.setAttribute(\"id\", id);\n  }\n  styles.forEach((styleList) => {\n    // each style returns a list\n    if (Object.keys(styleList).length) {\n      styleList.forEach((style) => {\n        const scoped = { \"@global\": style };\n        const sheet = j2c.sheet(scoped);\n        styleEl.appendChild(document.createTextNode(sheet));\n      });\n    }\n  });\n  document.head.appendChild(styleEl);\n};\n\nconst removeStyle = id => {\n  if (id) {\n    const old = document.getElementById(id);\n    if (old) {\n      old.parentNode.removeChild(old);\n    }\n  }\n};","import { addStyle } from \"./styler\";\nimport { classes } from \"./classes\";\n\nconst styles = [{\n  [\".\" + classes.scrollView]: {\n    \"-webkit-overflow-scrolling\": \"touch\",\n    height: \"100%\",\n\n    [\"&.\" + classes.scrollViewY]: {\n      overflowX: \"hidden\",\n      overflowY: \"auto\",\n      height: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        height: \"100%\"\n      }\n    },\n\n    [\"&.\" + classes.scrollViewX]: {\n      overflowX: \"auto\",\n      overflowY: \"hidden\",\n      width: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        width: \"100%\"\n      }\n    }\n  }\n  // by default unstyled:\n  // mithril-infinite__content\n  // mithril-infinite__pages\n  // mithril-infinite__page\n}];\n\naddStyle(\"mithril-infinite\", styles);\n","import m from \"mithril\";\nimport { classes } from \"./classes\";\nimport { getElementSize, isElementInViewport } from \"./util\";\nimport { page } from \"./page\";\nimport { placeholder } from \"./placeholder\";\nimport \"./css\";\n\nconst SCROLL_WATCH_TIMER = 200;\nconst SEL_PADDING = \"000000\";\n\nconst numToId = pageNum =>\n  SEL_PADDING.substring(0, SEL_PADDING.length - (\"\" + pageNum).length) + pageNum;\n\nconst calculateCurrentPageNum = (scrollAmount, state) => {\n  const pageNumKeys = state.sortedKeys;\n  let acc = state.beforeSize || 0;\n  let currentPageNum = 1;\n  for (let i = 0; i < pageNumKeys.length; i = i + 1) {\n    let pageKey = pageNumKeys[i];\n    if (scrollAmount > acc) {\n      currentPageNum = parseInt(pageKey, 10);\n    }\n    acc += state.pageSizes[pageKey];\n  }\n  return currentPageNum;\n};\n\nconst calculateContentSize = (from, to, state) => {\n  const fromIndex = Math.max(0, from - 1);\n  if (to < fromIndex) {\n    return 0;\n  }\n  const toIndex = to;\n  const pageNumKeys = state.sortedKeys.slice(fromIndex, toIndex);\n  let size = state.beforeSize || 0;\n  size = pageNumKeys.reduce((total, pageKey) => (\n    total += state.pageSizes[pageKey] || 0\n  ), size);\n  size += state.afterSize || 0;\n  return size;\n};\n\nconst isPageInViewport = (page, axis, state, scrollView) => {\n  if (!scrollView) {\n    return false;\n  }\n  const id = numToId(page);\n  const el = scrollView.querySelector(\"[data-page=\\\"\" + id + \"\\\"]\");\n  return isElementInViewport({ el, axis });\n};\n\nconst updatePageSize = ctrl => (pageId, size) => (\n  ctrl.state.pageSizes[pageId] = size,\n  ctrl.state.sortedKeys = Object.keys(ctrl.state.pageSizes).sort()\n);\n\nexport const infinite = {};\n\ninfinite.controller = (opts) => {\n  // Memoize some properties that do not change\n  const whichScroll = opts.axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n  const maxPages = opts.maxPages !== undefined ? opts.maxPages : Number.MAX_VALUE;\n  const autoSize = (opts.autoSize !== undefined && opts.autoSize === false) ? false : true;\n  const scrollThrottle = opts.throttle !== undefined ? opts.throttle * 1000 : SCROLL_WATCH_TIMER;\n  const contentTag = opts.contentTag || \"div\";\n\n  return {\n    state: {\n      pageSizes: {},\n      sortedKeys: [],\n      beforeSize: null,\n      afterSize: null\n    },\n    scrollView: null,\n    isScrolling: false,\n    scrollWatchScrollingStateId: null,\n    scrollWatchUpdateStateId: null,\n    preloadSlots: opts.preloadPages || 1,\n    boundingClientRect: {},\n    currentPageNum: 0,\n    scrollAmount: 0,\n\n    // Memoized\n    whichScroll,\n    maxPages,\n    autoSize,\n    scrollThrottle,\n    contentTag\n  };\n};\n\ninfinite.view = (ctrl, opts) => {\n  const state = ctrl.state;\n  ctrl.scrollAmount = ctrl.scrollView ? ctrl.scrollView[ctrl.whichScroll] : 0;\n  \n  const currentPageNum = opts.currentPage\n    ? parseInt(opts.currentPage, 10)\n    : calculateCurrentPageNum(ctrl.scrollAmount, state);\n\n  if (currentPageNum !== ctrl.currentPageNum && opts.pageChange) {\n    opts.pageChange(currentPageNum);\n  }\n  ctrl.currentPageNum = currentPageNum;\n\n  if (ctrl.scrollView && opts.getDimensions) {\n    opts.getDimensions({\n      scrolled: ctrl.scrollAmount,\n      size: ctrl.contentSize\n    });\n  }\n\n  const minPageNum = opts.from\n    ? parseInt(opts.from, 10)\n    : opts.currentPage\n      ? opts.currentPage\n      : 1;\n  const maxPageNum = opts.to\n    ? parseInt(opts.to, 10)\n    : opts.currentPage\n      ? opts.currentPage\n      : ctrl.maxPages;\n  const pages = [];\n  const prePages = [];\n  for (let i = -ctrl.preloadSlots; i <= ctrl.preloadSlots; i = i + 1) {\n    const pageNum = currentPageNum + i;\n    if (pageNum >= minPageNum && pageNum <= maxPageNum) {\n      pages.push(pageNum);\n    }\n  }\n  for (let pageNum = 1; pageNum < pages[0]; pageNum = pageNum + 1) {\n    prePages.push(pageNum);\n  }\n\n  const classList = [\n    classes.scrollView,\n    opts.axis === \"x\"\n      ? classes.scrollViewX\n      : classes.scrollViewY,\n    opts.class\n  ].join(\" \");\n  ctrl.contentSize = calculateContentSize(1, maxPageNum, state);\n  const isLastPageVisible = maxPageNum\n    ? isPageInViewport(maxPageNum, opts.axis, state, ctrl.scrollView)\n    : true;\n\n  if (ctrl.scrollView) {\n    // in case the screen size was changed, reset preloadSlots\n    const boundingClientRect = ctrl.scrollView.getBoundingClientRect();\n    ctrl.boundingClientRect = ctrl.boundingClientRect || boundingClientRect;\n    if (boundingClientRect.width !== ctrl.boundingClientRect.width\n      || boundingClientRect.height !== ctrl.boundingClientRect.height\n    ) {\n      ctrl.preloadSlots = opts.preloadPages || 1;\n    }\n    ctrl.boundingClientRect = boundingClientRect;\n    // calculate if we have room to load more\n    const maxSlots = opts.maxPreloadPages || Number.MAX_VALUE;\n\n    if (ctrl.contentSize\n      && (ctrl.preloadSlots < pages.length)\n      && (ctrl.preloadSlots <= maxSlots)\n      && (ctrl.contentSize < boundingClientRect.height)\n    ) {\n      ctrl.preloadSlots++;\n      setTimeout(m.redraw, 0);\n    }\n  }\n\n  return m(\"div\", {\n    config: (el, inited, context) => {\n      if (inited) {\n        return;\n      }\n      if (opts.scrollView) {\n        ctrl.scrollView = document.querySelector(opts.scrollView);\n      } else {\n        ctrl.scrollView = el;\n      }\n      ctrl.scrollView.className += \" \" + classList;\n\n      if (opts.setDimensions) {\n        const dimensions = opts.setDimensions();\n        const whichSize = opts.axis === \"x\"\n          ? \"width\"\n          : \"height\";\n        if (dimensions.size > 0) {\n          el.style[whichSize] = dimensions.size + \"px\";\n        }\n        ctrl.scrollView[ctrl.whichScroll] = dimensions.scrolled;\n      }\n\n      const handleScroll = () => {\n        ctrl.isScrolling = true;\n\n        // reset isScrolling state only when scrolling is done\n        clearTimeout(ctrl.scrollWatchScrollingStateId);\n        ctrl.scrollWatchScrollingStateId = setTimeout(() => {\n          ctrl.isScrolling = false;\n          // update pages\n          m.redraw();\n        }, ctrl.scrollThrottle);\n\n        // throttle updates while scrolling\n        if (!ctrl.scrollWatchUpdateStateId) {\n          ctrl.scrollWatchUpdateStateId = setTimeout(() => {\n            // update pages\n            m.redraw();\n            ctrl.scrollWatchUpdateStateId = null;\n          }, ctrl.scrollThrottle);\n        }\n      };\n      ctrl.scrollView.addEventListener(\"scroll\", handleScroll);\n      context.onunload = () => {\n        ctrl.scrollView.removeEventListener(\"scroll\", handleScroll);\n      };\n    }\n  }, m(\"div\", {\n    class: classes.scrollContent,\n    style: !ctrl.autoSize\n      ? {}\n      : Object.assign(\n        {},\n        opts.axis === \"x\"\n          ? { width: ctrl.contentSize + \"px\" }\n          : { height: ctrl.contentSize + \"px\" },\n        opts.contentSize\n          ? opts.axis === \"x\"\n            ? { \"min-width\": opts.contentSize + \"px\" }\n            : { \"min-height\": opts.contentSize + \"px\" }\n          : {}\n    )\n  }, [\n    m(ctrl.contentTag, { class: classes.content }, [\n      opts.before\n        ? m(\"div\", {\n          class: classes.before,\n          config: el => {\n            // always update the natural size\n            const size = getElementSize(el, opts.axis);\n            if (size) {\n              state.beforeSize = size;\n            }\n          }\n        }, opts.before)\n        : null,\n      m(\"div\", { class: classes.pages }, [\n        prePages.map(pageNum => \n          m(placeholder, Object.assign(\n            {},\n            opts,\n            {\n              pageNum,\n              pageId: numToId(pageNum),\n              pageSizes: state.pageSizes\n            }\n          ))\n        ),\n        pages.map(pageNum =>\n          m(page, Object.assign(\n            {},\n            opts,\n            {\n              pageNum,\n              pageId: numToId(pageNum),\n              isScrolling: ctrl.isScrolling,\n              pageSizes: state.pageSizes,\n              updatePageSize: updatePageSize(ctrl),\n              autoSize: ctrl.autoSize\n            }\n          ))\n        )\n      ]),\n      // only show \"after\" when content is available\n      opts.after && ctrl.contentSize\n        ? m(\"div\", {\n          class: classes.after,\n          style: {\n            // visually hide this element until the last page is into view\n            // to prevent flashes of after content when scrolling fast\n            visibility: isLastPageVisible ? \"visible\" : \"hidden\"\n          },\n          config: el => {\n            // always update the natural size\n            const size = getElementSize(el, opts.axis);\n            if (size) {\n              state.afterSize = size;\n            }\n          }\n        }, opts.after)\n        : null\n    ])\n  ]));\n};\n\ninfinite.isElementInViewport = isElementInViewport;\n\n"],"names":["classes","getElementSize","el","axis","styles","window","getComputedStyle","margin","parseFloat","marginLeft","marginRight","scrollWidth","marginTop","marginBottom","scrollHeight","isElementInViewport","leeway","verge","inY","inX","inViewport","makeClassName","page","pageNum","pageEven","pageOdd","join","getPageData","m","request","controller","opts","content","prop","pageData","result","then","r","redraw","pageUrl","url","data","pageTag","view","ctrl","pageId","storedPageSize","pageSizes","pageSize","updatePageSize","cssSize","autoSize","isScrolling","processPageData","opts1","map","index","item","className","_extends","width","height","size","placeholder","j2c","J2c","removeStyle","id","old","document","getElementById","parentNode","removeChild","scrollView","scrollViewY","scrollContent","scrollViewX","styleEl","createElement","setAttribute","forEach","styleList","Object","keys","length","style","scoped","@global","sheet","appendChild","createTextNode","head","SEL_PADDING","numToId","substring","calculateCurrentPageNum","scrollAmount","state","pageNumKeys","sortedKeys","acc","beforeSize","currentPageNum","i","pageKey","parseInt","calculateContentSize","from","to","fromIndex","Math","max","toIndex","slice","reduce","total","afterSize","isPageInViewport","querySelector","sort","infinite","whichScroll","maxPages","undefined","Number","MAX_VALUE","scrollThrottle","throttle","contentTag","preloadPages","currentPage","pageChange","getDimensions","contentSize","minPageNum","maxPageNum","pages","prePages","preloadSlots","push","classList","class","isLastPageVisible","boundingClientRect","getBoundingClientRect","maxSlots","maxPreloadPages","inited","context","setDimensions","dimensions","whichSize","scrolled","handleScroll","scrollWatchScrollingStateId","setTimeout","scrollWatchUpdateStateId","addEventListener","onunload","removeEventListener","min-width","min-height","before","after"],"mappings":"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"}