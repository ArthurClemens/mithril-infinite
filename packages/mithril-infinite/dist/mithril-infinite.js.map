{"version":3,"file":"mithril-infinite.js","sources":["../node_modules/j2c/src/helpers.js","../node_modules/j2c/src/declarations.js","../node_modules/j2c/src/at-rules.js","../node_modules/j2c/src/rules.js","../node_modules/j2c/src/main.js","../src/classes.js","../node_modules/verge/verge.js","../src/util.js","../src/page.js","../src/placeholder.js","../src/styler.js","../src/css.js","../src/index.js"],"sourcesContent":["var\n  emptyObject = {},\n  type = emptyObject.toString,\n  ARRAY =  type.call([]),\n  NUMBER = type.call(0),\n  OBJECT = type.call(emptyObject),\n  STRING = type.call(''),\n  FUNCTION = type.call(type),\n  own =  emptyObject.hasOwnProperty,\n  freeze = Object.freeze || function(o) {return o}\n\n\nfunction defaults(target, source) {\n  for (var k in source) if (own.call(source, k)) {\n    if (k.indexOf('$') && !(k in target)) target[k] = source[k]\n  }\n  return target\n}\n\nfunction cartesian(a,b) {\n  var res = [], i, j\n  for (j in b) if(own.call(b, j))\n    for (i in a) if(own.call(a, i))\n      res.push(a[i] + b[j])\n  return res\n}\n\n// \"Tokenizes\" the selectors into parts relevant for the next function.\n// Strings and comments are matched, but ignored afterwards.\n// This is not a full tokenizers. It only recognizes comas, parentheses,\n// strings and comments.\n// regexp generated by scripts/regexps.js then trimmed by hand\nvar selectorTokenizer = /[(),]|\"(?:\\\\.|[^\"\\n])*\"|'(?:\\\\.|[^'\\n])*'|\\/\\*[\\s\\S]*?\\*\\//g\n\n\n/**\n * This will split a coma-separated selector list into individual selectors,\n * ignoring comas in strings, comments and in :pseudo-selectors(parameter, lists).\n *\n * @param {string} selector\n * @return {string[]}\n */\n\nfunction splitSelector(selector) {\n  var indices = [], res = [], inParen = 0, o\n  /*eslint-disable no-cond-assign*/\n  while (o = selectorTokenizer.exec(selector)) {\n  /*eslint-enable no-cond-assign*/\n    switch (o[0]) {\n    case '(': inParen++; break\n    case ')': inParen--; break\n    case ',': if (inParen) break; indices.push(o.index)\n    }\n  }\n  for (o = indices.length; o--;){\n    res.unshift(selector.slice(indices[o] + 1))\n    selector = selector.slice(0, indices[o])\n  }\n  res.unshift(selector)\n  return res\n}\n\n// Like the `selectorTokenizer`, but for the `&` operator\nvar ampersandTokenizer = /&|\"(?:\\\\.|[^\"\\n])*\"|'(?:\\\\.|[^'\\n])*'|\\/\\*[\\s\\S]*?\\*\\//g\n\nfunction ampersand (selector, parents) {\n  var indices = [], split = [], res, o\n  /*eslint-disable no-cond-assign*/\n  while (o = ampersandTokenizer.exec(selector)) {\n  /*eslint-enable no-cond-assign*/\n    if (o[0] == '&') indices.push(o.index)\n  }\n  for (o = indices.length; o--;){\n    split.unshift(selector.slice(indices[o] + 1))\n    selector = selector.slice(0, indices[o])\n  }\n  split.unshift(selector)\n  if (split.length === 1) split.unshift('')\n  res = [split[0]]\n  for (o = 1; o < split.length; o++) {\n    res = cartesian(res, cartesian(parents, [split[o]]))\n  }\n  return res.join(',')\n}\n\nfunction flatIter (f) {\n  return function iter(arg) {\n    if (type.call(arg) === ARRAY) for (var i= 0 ; i < arg.length; i ++) iter(arg[i])\n    else f(arg)\n  }\n}\n\nvar chars = ''\nfunction randChars(n) {\n  while(chars.length < n) chars += Math.floor(Math.random() * 0x100000000).toString(36)\n  var res = '_' + chars.slice(0, n)\n  chars = chars.slice(n)\n  return res\n}\n\nexport {\n  ARRAY, FUNCTION, NUMBER, OBJECT, STRING,\n  ampersand, cartesian, defaults,\n  flatIter, freeze, own,\n  randChars, splitSelector, type\n}","import {own, type, ARRAY, OBJECT} from './helpers'\n\nfunction decamelize(match) {\n  return '-' + match.toLowerCase()\n}\n\n/**\n * Handles the property:value; pairs.\n *\n * @param {object} state - holds the localizer- and walker-related methods\n *                         and state\n * @param {object} emit - the contextual emitters to the final buffer\n * @param {string} prefix - the current property or a prefix in case of nested\n *                          sub-properties.\n * @param {array|object|string} o - the declarations.\n * @param {boolean} local - are we in @local or in @global scope.\n */\n\nexport function declarations(state, emit, prefix, o, local) {\n  var k, v, kk\n  if (o==null) return\n\n  switch ( type.call(o = o.valueOf()) ) {\n  case ARRAY:\n    for (k = 0; k < o.length; k++)\n\n      declarations(state, emit, prefix, o[k], local)\n\n    break\n  case OBJECT:\n    // prefix is falsy iif it is the empty string, which means we're at the root\n    // of the declarations list.\n    prefix = (prefix && prefix + '-')\n    for (k in o) if (own.call(o, k)){\n      v = o[k]\n      if (/\\$/.test(k)) {\n        for (kk in (k = k.split('$'))) if (own.call(k, kk)) {\n\n          declarations(state, emit, prefix + k[kk], v, local)\n\n        }\n      } else {\n\n        declarations(state, emit, prefix + k, v, local)\n\n      }\n    }\n    break\n  default:\n    // prefix is falsy when it is \"\", which means that we're\n    // at the top level.\n    // `o` is then treated as a `property:value` pair, or a\n    // semi-colon-separated list thereof.\n    if (!prefix) return emit.raw(o)\n\n    // Otherwise, `prefix` is the property name, and\n    // `o` is the value.\n\n    // restore the dashes\n    k = prefix.replace(/_/g, '-').replace(/[A-Z]/g, decamelize)\n\n    if (local && (k == 'animation-name' || k == 'animation')) {\n      // no need to tokenize here a plain `.split(',')` has all bases covered.\n      // We may 'localize' a comment, but it's not a big deal.\n      o = o.split(',').map(function (o) {\n\n        return o.replace(/^\\s*(?:(var\\([^)]+\\))|:?global\\(\\s*([_A-Za-z][-\\w]*)\\s*\\)|()(-?[_A-Za-z][-\\w]*))/, state.localizeReplacer)\n\n      }).join(',')\n    }\n\n    emit.decl(k, o)\n  }\n}\n","import {flatIter} from './helpers'\nimport {rules} from './rules'\nimport {declarations} from './declarations'\n\n/**\n * Handles a single at-rules\n *\n * @param {object} state - holds the localizer- and walker-related methods\n *                         and state\n * @param {object} emit - the contextual emitters to the final buffer\n * @param {array} k - The parsed at-rule, including the parameters,\n *                    if takes both parameters and a block.\n *                    k == [match, fullAtRule, atRuleType, params?]\n *                    So in `@-webkit-keyframes foo`, we have\n *                     - match = \"@-webkit-keyframes foo\"\n *                     - fullAtRule = \"@-webkit-keyframes\"\n *                     - atRuleType = \"keyframes\"\n *                     - params = \"foo\"\n * @param {string|string[]|object|object[]} v - Either parameters for\n *                                              block-less rules or\n *                                              their block\n *                                              for the others.\n * @param {string} prefix - the current selector or the selector prefix\n *                          in case of nested rules\n * @param {boolean} local - are we in @local or in @global scope?\n * @param {string} nestingDepth - are we nested in an at-rule or a selector?\n */\n\nexport function atRules(state, emit, k, v, prefix, local, nestingDepth) {\n\n  // First iterate over user-provided at-rules and return if one of them corresponds to the current one\n  for (var i = 0; i < state.atruleHandlers.length; i++) {\n\n    if (state.atruleHandlers[i](state, emit, k, v, prefix, local, nestingDepth)) return\n\n  }\n\n  // using `/^global$/.test(k[2])` rather that 'global' == k[2] gzips\n  // slightly better thanks to the regexps tests further down.\n  // It is slightly less efficient but this isn't a critical path.\n\n  if (!k[3] && /^global$/.test(k[2])) {\n\n    rules(state, emit, prefix, v, 0, nestingDepth)\n\n\n  } else if (!k[3] && /^local$/.test(k[2])) {\n\n    rules(state, emit, prefix, v, 1, nestingDepth)\n\n\n  } else if (k[3] && /^adopt$/.test(k[2])) {\n\n    if (!local || nestingDepth) return emit.err('@adopt global or nested: ' + k[0])\n\n    if (!/^\\.?[_A-Za-z][-\\w]*$/.test(k[3])) return emit.err('bad adopter ' + JSON.stringify(k[3]) + ' in ' + k[0])\n\n    i = []\n    flatIter(function(adoptee, asString) {\n\n      if(adoptee == null || !/^\\.?[_A-Za-z][-\\w]*(?:\\s+\\.?[_A-Za-z][-\\w]*)*$/.test(asString = adoptee + '')) emit.err('bad adoptee '+ JSON.stringify(adoptee) + ' in ' + k[0])\n\n      else i.push(asString.replace(/\\./g, ''))\n\n    })(v)\n\n    // we may end up with duplicate classes but AFAIK it has no consequences on specificity.\n    if (i.length) {\n      state.localize(k[3] = k[3].replace(/\\./g, ''))\n      state.names[k[3]] += (' ' + i.join(' '))\n    }\n\n\n  } else if (!k[3] && /^(?:namespace|import|charset)$/.test(k[2])) {\n    flatIter(function(v) {\n\n      emit.atrule(k[1], k[2], v)\n\n    })(v)\n\n\n  } else if (!k[3] && /^(?:font-face|viewport)$/.test(k[2])) {\n    flatIter(function(v) {\n\n      emit.atrule(k[1], k[2], k[3], 'decl')\n\n      declarations(state, emit, '', v, local)\n\n      emit._atrule()\n\n    })(v)\n\n  } else if (k[3] && /^(?:media|supports|page|keyframes)$/.test(k[2])) {\n\n    if (local && 'keyframes' == k[2]) {\n      k[3] = k[3].replace(\n        // generated by script/regexps.js\n        /(var\\([^)]+\\))|:?global\\(\\s*([_A-Za-z][-\\w]*)\\s*\\)|()(-?[_A-Za-z][-\\w]*)/,\n        state.localizeReplacer\n      )\n    }\n\n    if ('page' == k[2]) {\n\n      emit.atrule(k[1], k[2], k[3], 'decl')\n\n      declarations(state, emit, '', v, local)\n\n    } else {\n\n      emit.atrule(k[1], k[2], k[3], 'rule')\n\n      rules(\n        state, emit,\n        'keyframes' == k[2] ? '' : prefix,\n        v, local, nestingDepth + 1\n      )\n\n    }\n\n    emit._atrule()\n\n  } else {\n\n    emit.err('Unsupported at-rule: ' + k[0])\n\n  }\n}\n","import {type, ARRAY, OBJECT, STRING, ampersand, own, splitSelector} from './helpers'\nimport {declarations} from './declarations'\nimport {atRules} from './at-rules'\n\n/**\n * Add rulesets and other CSS tree to the sheet.\n *\n * @param {object} state - holds the localizer- and walker-related methods\n *                         and state\n * @param {object} emit - the contextual emitters to the final buffer\n * @param {string} prefix - the current selector or a prefix in case of nested rules\n * @param {array|string|object} tree - a source object or sub-object.\n * @param {string} nestingDepth - are we nested in an at-rule?\n * @param {boolean} local - are we in @local or in @global scope?\n */\nexport function rules(state, emit, prefix, tree, local, nestingDepth) {\n  var k, v, inDeclaration, kk\n\n  switch (type.call(tree)) {\n\n  case OBJECT:\n    for (k in tree) if (own.call(tree, k)) {\n      v = tree[k]\n\n      if (prefix.length > 0 && /^[-\\w$]+$/.test(k)) {\n        if (!inDeclaration) {\n          inDeclaration = 1\n\n          emit.rule(prefix)\n\n        }\n        if (/\\$/.test(k)) {\n          for (kk in (k = k.split('$'))) if (own.call(k, kk)) {\n\n            declarations(state, emit, k[kk], v, local)\n\n          }\n        } else {\n\n          declarations(state, emit, k, v, local)\n\n        }\n\n      } else if (/^@/.test(k)) {\n        // Handle At-rules\n        inDeclaration = 0\n\n        atRules(state, emit,\n          /^(.(?:-[\\w]+-)?([_A-Za-z][-\\w]*))\\b\\s*(.*?)\\s*$/.exec(k) || [k,'@','',''],\n          v, prefix, local, nestingDepth\n        )\n\n      } else {\n        // selector or nested sub-selectors\n        inDeclaration = 0\n\n        if (k === '') {\n          emit._rule()\n          emit.err(\"Invalid selector ''\")\n          continue\n        }\n\n        rules(\n          state, emit,\n          // build the selector `prefix` for the next iteration.\n          // ugly and full of redundant bits but so far the fastest/shortest.gz\n          /*0 if*/(prefix.length > 0 && (/,/.test(prefix) || /,/.test(k))) ?\n\n            /*0 then*/ (kk = splitSelector(prefix), splitSelector(\n              local ?\n\n                k.replace(\n                  /(\"(?:\\\\.|[^\"\\n])*\"|'(?:\\\\.|[^'\\n])*'|\\/\\*[\\s\\S]*?\\*\\/)|:global\\(\\s*(\\.-?[_A-Za-z][-\\w]*)\\s*\\)|(\\.)(-?[_A-Za-z][-\\w]*)/g,\n                  state.localizeReplacer\n                ) :\n\n                k\n            ).map(function (k) {\n              return /&/.test(k) ? ampersand(k, kk) : kk.map(function(kk) {\n                return kk + k\n              }).join(',')\n            }).join(',')) :\n\n            /*0 else*/ /*1 if*/ /&/.test(k) ?\n\n              /*1 then*/ ampersand(\n                local ?\n\n                  k.replace(\n                    /(\"(?:\\\\.|[^\"\\n])*\"|'(?:\\\\.|[^'\\n])*'|\\/\\*[\\s\\S]*?\\*\\/)|:global\\(\\s*(\\.-?[_A-Za-z][-\\w]*)\\s*\\)|(\\.)(-?[_A-Za-z][-\\w]*)/g,\n                    state.localizeReplacer\n                  ) :\n\n                  k,\n                [prefix]\n              ) :\n\n              /*1 else*/ prefix + (\n                local ?\n\n                  k.replace(\n                    /(\"(?:\\\\.|[^\"\\n])*\"|'(?:\\\\.|[^'\\n])*'|\\/\\*[\\s\\S]*?\\*\\/)|:global\\(\\s*(\\.-?[_A-Za-z][-\\w]*)\\s*\\)|(\\.)(-?[_A-Za-z][-\\w]*)/g,\n                    state.localizeReplacer\n                  ) :\n\n                  k\n                ),\n           v, local, nestingDepth + 1\n        )\n\n      }\n    }\n\n    break\n\n  case ARRAY:\n    for (k = 0; k < tree.length; k++){\n\n      rules(state, emit, prefix, tree[k], local, nestingDepth)\n\n    }\n    break\n\n  case STRING:\n    // CSS hacks or ouptut of `j2c.inline`. Even raw rulesets if in top position.\n\n    if (prefix.length) emit.rule(prefix)\n\n    emit.raw(tree)\n\n  }\n}\n\n// This is the first entry in the filters array, which is\n// actually the last step of the compiler. It inserts\n// closing braces to close normal (non at-) rules (those\n// that start with a selector). Doing it earlier is\n// impossible without passing state around in unrelated code\n// or ending up with duplicated selectors when the source tree\n// contains arrays.\n// There's no `_rule` handler, because the core compiler never\n// calls it.\nexport function closeSelectors(next, inline) {\n  var lastSelector\n  return inline ? next : {\n    init: function(){lastSelector = ''; next.init()},\n    done: function () {\n      if (lastSelector) {next._rule(); lastSelector = ''}\n      return next.done()\n    },\n    atrule: function (rule, kind, param, takesBlock) {\n      if (lastSelector) {next._rule(); lastSelector = ''}\n      next.atrule(rule, kind, param, takesBlock)\n    },\n    _atrule: function (rule) {\n      if (lastSelector) {next._rule(); lastSelector = ''}\n      next._atrule(rule)\n    },\n    rule: function (selector) {\n      if (selector !== lastSelector){\n        if (lastSelector) next._rule()\n        next.rule(selector)\n        lastSelector = selector\n      }\n    },\n    _rule: function(){\n      if (lastSelector) {next._rule(); lastSelector = ''}\n    }\n  }\n}\n","import {defaults, flatIter, freeze, randChars, own, type, ARRAY, FUNCTION, NUMBER, OBJECT, STRING} from './helpers'\nimport {closeSelectors, rules} from './rules'\nimport {declarations} from './declarations'\n\nfunction invoke(fn, tree, state, backend) {\n  backend.init()\n  try{\n    fn(\n      state,\n      backend,\n      '', // prefix\n      tree,\n      1,  // local, by default\n      0   // nesting depth, only for sheet\n    )\n  } catch(e) {backend.err(e instanceof Error ? e.stack : '' + e)}\n  return backend.done()\n}\n\nfunction makeInstance(prefix, suffix, atruleHandlers, nsCache, backend, setPropList) {\n  var names = {}\n  function localize(name) {\n    if (!own.call(names, name)) names[name] = prefix + name + suffix\n    return names[name].match(/^\\S+/)\n  }\n  var state =  {\n    atruleHandlers: atruleHandlers,\n    names: names,\n    /**\n     * Returns a localized version of a given name.\n     * Registers the pair in `instnace.name` if needed.\n     *\n     * @param {string} name - the name to localize\n     * @return {string} - the localized version\n     */\n    localize: localize,\n    /**\n     * Used as second argument for str.replace(localizeRegex, replacer)\n     * `ignore`, `global` and `(dot, name)` are mutually exclusive\n     *\n     * @param {string} match - the whole match (ignored)\n     * @param {string|null} ignore - a comment or a string literal\n     * @param {string|null} global - a global name\n     * @param {string|null} dot - either '.' for a local class name or the empty string otherwise\n     * @param {string|null} name - the name to localize\n     * @return {string}\n     */\n    localizeReplacer: function (match, ignore, global, dot, name) {\n      return ignore || global || dot + localize(name)\n    }\n  }\n\n  var instance = {\n    ns: function(name) {\n      var prefix = '__'+name.replace(/\\W+/g, '_') + '_'\n      if (!own.call(nsCache, prefix)) {\n        nsCache[prefix] = makeInstance(prefix, suffix, atruleHandlers, nsCache, backend, setPropList)\n      }\n      return nsCache[prefix]\n    },\n    names: names,\n    prefix: prefix,\n    suffix: suffix,\n    sheet: function(tree) {return invoke(rules, tree, state, backend[0])},\n    inline: function (tree) {return invoke(declarations, tree, state, backend[1])}\n  }\n  for (var i = setPropList.length; i--;) defaults(instance, setPropList[i])\n  return instance\n}\n\nexport default function J2c(options) {\n  options = options || {}\n  // the buffer that accumulates the output. Initialized in `$sink.init()`\n  var buf, err\n\n  // the default sink.\n  var _backend = [{\n    init: function () {buf=[], err=[]},\n    done: function (raw) {\n      if (err.length != 0) throw new Error('j2c error(s): ' + JSON.stringify(err,null,2) + 'in context:\\n' + buf.join(''))\n      return raw ? buf : buf.join('')\n    },\n    err: function (msg) {\n      err.push(msg)\n      buf.push('/* +++ ERROR +++ ' + msg + ' */\\n')\n    },\n    raw: function (str) {buf.push(str, '\\n')},\n    atrule: function (rule, kind, param, takesBlock) {\n      buf.push(rule, param && ' ', param, takesBlock ? ' {\\n' : ';\\n')\n    },\n    // close atrule\n    _atrule: function () {buf.push('}\\n')},\n    rule: function (selector) {buf.push(selector, ' {\\n')},\n    // close rule\n    _rule: function () {buf.push('}\\n')},\n    decl: function (prop, value) {buf.push(prop, ':', value, ';\\n')}\n  }]\n\n  // holds the `_filter` and `atrule` handlers\n  var _filters = [closeSelectors]\n  var _atruleHandlers = []\n  var _setPropList = []\n  var _suffix = randChars(7)\n  var _nsCache = {}\n\n  // the public API (see the main docs)\n\n\n  // handler options\n  if (type.call(options.plugins) === ARRAY) {\n    flatIter(function(plugin) {\n      if (type.call(plugin) !== OBJECT) throw new Error('bad plugin, object expected, got '+ type.call(plugin))\n\n      if (type.call(plugin.filter) === FUNCTION) _filters.push(plugin.filter)\n      if (type.call(plugin.atrule) === FUNCTION) _atruleHandlers.push(plugin.atrule)\n      if (type.call(plugin.sink) === FUNCTION) _backend = plugin.sink()\n      if (type.call(plugin.set) === OBJECT) _setPropList.push(plugin.set)\n    })(options.plugins)\n  }\n  if (type.call(options.suffix) === STRING) _suffix = options.suffix\n  if (type.call(options.suffix) === NUMBER) _suffix = randChars(options.suffix)\n\n  _backend[1] = _backend[1] || {\n    init: _backend[0].init,\n    done: _backend[0].done,\n    raw: _backend[0].raw,\n    err: _backend[0].err,\n    decl: _backend[0].decl\n  }\n\n  // finalize the backend by merging in the filters\n  for(var i = 0; i < 2; i++){ // 0 for j2c.sheet, 1 for j2c.inline\n    for (var j = _filters.length; j--;) {\n      _backend[i] = freeze(\n        defaults(\n          _filters[j](_backend[i], !!i),\n          _backend[i]\n        )\n      )\n    }\n  }\n  return freeze(makeInstance('', _suffix, _atruleHandlers, _nsCache, _backend, _setPropList))\n}\n","\nexport const classes = {\n  scrollView:    \"mithril-infinite__scroll-view\",\n  scrollViewX:   \"mithril-infinite__scroll-view--x\",\n  scrollViewY:   \"mithril-infinite__scroll-view--y\",\n  scrollContent: \"mithril-infinite__scroll-content\",\n  content:       \"mithril-infinite__content\",\n  pages:         \"mithril-infinite__pages\",\n  page:          \"mithril-infinite__page\",\n  pageEven:      \"mithril-infinite__page--even\",\n  pageOdd:       \"mithril-infinite__page--odd\",\n  before:        \"mithril-infinite__before\",\n  after:         \"mithril-infinite__after\"\n};\n","/*!\r\n * verge 1.9.1+201402130803\r\n * https://github.com/ryanve/verge\r\n * MIT License 2013 Ryan Van Etten\r\n */\r\n\r\n(function(root, name, make) {\r\n  if (typeof module != 'undefined' && module['exports']) module['exports'] = make();\r\n  else root[name] = make();\r\n}(this, 'verge', function() {\r\n\r\n  var xports = {}\r\n    , win = typeof window != 'undefined' && window\r\n    , doc = typeof document != 'undefined' && document\r\n    , docElem = doc && doc.documentElement\r\n    , matchMedia = win['matchMedia'] || win['msMatchMedia']\r\n    , mq = matchMedia ? function(q) {\r\n        return !!matchMedia.call(win, q).matches;\r\n      } : function() {\r\n        return false;\r\n      }\r\n    , viewportW = xports['viewportW'] = function() {\r\n        var a = docElem['clientWidth'], b = win['innerWidth'];\r\n        return a < b ? b : a;\r\n      }\r\n    , viewportH = xports['viewportH'] = function() {\r\n        var a = docElem['clientHeight'], b = win['innerHeight'];\r\n        return a < b ? b : a;\r\n      };\r\n  \r\n  /** \r\n   * Test if a media query is active. Like Modernizr.mq\r\n   * @since 1.6.0\r\n   * @return {boolean}\r\n   */  \r\n  xports['mq'] = mq;\r\n\r\n  /** \r\n   * Normalized matchMedia\r\n   * @since 1.6.0\r\n   * @return {MediaQueryList|Object}\r\n   */ \r\n  xports['matchMedia'] = matchMedia ? function() {\r\n    // matchMedia must be binded to window\r\n    return matchMedia.apply(win, arguments);\r\n  } : function() {\r\n    // Gracefully degrade to plain object\r\n    return {};\r\n  };\r\n\r\n  /**\r\n   * @since 1.8.0\r\n   * @return {{width:number, height:number}}\r\n   */\r\n  function viewport() {\r\n    return {'width':viewportW(), 'height':viewportH()};\r\n  }\r\n  xports['viewport'] = viewport;\r\n  \r\n  /** \r\n   * Cross-browser window.scrollX\r\n   * @since 1.0.0\r\n   * @return {number}\r\n   */\r\n  xports['scrollX'] = function() {\r\n    return win.pageXOffset || docElem.scrollLeft; \r\n  };\r\n\r\n  /** \r\n   * Cross-browser window.scrollY\r\n   * @since 1.0.0\r\n   * @return {number}\r\n   */\r\n  xports['scrollY'] = function() {\r\n    return win.pageYOffset || docElem.scrollTop; \r\n  };\r\n\r\n  /**\r\n   * @param {{top:number, right:number, bottom:number, left:number}} coords\r\n   * @param {number=} cushion adjustment\r\n   * @return {Object}\r\n   */\r\n  function calibrate(coords, cushion) {\r\n    var o = {};\r\n    cushion = +cushion || 0;\r\n    o['width'] = (o['right'] = coords['right'] + cushion) - (o['left'] = coords['left'] - cushion);\r\n    o['height'] = (o['bottom'] = coords['bottom'] + cushion) - (o['top'] = coords['top'] - cushion);\r\n    return o;\r\n  }\r\n\r\n  /**\r\n   * Cross-browser element.getBoundingClientRect plus optional cushion.\r\n   * Coords are relative to the top-left corner of the viewport.\r\n   * @since 1.0.0\r\n   * @param {Element|Object} el element or stack (uses first item)\r\n   * @param {number=} cushion +/- pixel adjustment amount\r\n   * @return {Object|boolean}\r\n   */\r\n  function rectangle(el, cushion) {\r\n    el = el && !el.nodeType ? el[0] : el;\r\n    if (!el || 1 !== el.nodeType) return false;\r\n    return calibrate(el.getBoundingClientRect(), cushion);\r\n  }\r\n  xports['rectangle'] = rectangle;\r\n\r\n  /**\r\n   * Get the viewport aspect ratio (or the aspect ratio of an object or element)\r\n   * @since 1.7.0\r\n   * @param {(Element|Object)=} o optional object with width/height props or methods\r\n   * @return {number}\r\n   * @link http://w3.org/TR/css3-mediaqueries/#orientation\r\n   */\r\n  function aspect(o) {\r\n    o = null == o ? viewport() : 1 === o.nodeType ? rectangle(o) : o;\r\n    var h = o['height'], w = o['width'];\r\n    h = typeof h == 'function' ? h.call(o) : h;\r\n    w = typeof w == 'function' ? w.call(o) : w;\r\n    return w/h;\r\n  }\r\n  xports['aspect'] = aspect;\r\n\r\n  /**\r\n   * Test if an element is in the same x-axis section as the viewport.\r\n   * @since 1.0.0\r\n   * @param {Element|Object} el\r\n   * @param {number=} cushion\r\n   * @return {boolean}\r\n   */\r\n  xports['inX'] = function(el, cushion) {\r\n    var r = rectangle(el, cushion);\r\n    return !!r && r.right >= 0 && r.left <= viewportW();\r\n  };\r\n\r\n  /**\r\n   * Test if an element is in the same y-axis section as the viewport.\r\n   * @since 1.0.0\r\n   * @param {Element|Object} el\r\n   * @param {number=} cushion\r\n   * @return {boolean}\r\n   */\r\n  xports['inY'] = function(el, cushion) {\r\n    var r = rectangle(el, cushion);\r\n    return !!r && r.bottom >= 0 && r.top <= viewportH();\r\n  };\r\n\r\n  /**\r\n   * Test if an element is in the viewport.\r\n   * @since 1.0.0\r\n   * @param {Element|Object} el\r\n   * @param {number=} cushion\r\n   * @return {boolean}\r\n   */\r\n  xports['inViewport'] = function(el, cushion) {\r\n    // Equiv to `inX(el, cushion) && inY(el, cushion)` but just manually do both \r\n    // to avoid calling rectangle() twice. It gzips just as small like this.\r\n    var r = rectangle(el, cushion);\r\n    return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= viewportH() && r.left <= viewportW();\r\n  };\r\n\r\n  return xports;\r\n}));","import verge from \"verge\";\nimport { classes } from \"./classes\";\n\nconst LEEWAY = 300;\n\nexport const getElementSize = (el, axis) => {\n  const styles = window.getComputedStyle(el);\n  if (axis === \"x\") {\n    const margin = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    return el.scrollWidth + margin;\n  } else {\n    const margin = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    return el.scrollHeight + margin;\n  }\n};\n\n// el, axis = \"y\", expand = LEEWAY\nexport const isElementInViewport = ({el, axis = \"y\", leeway = LEEWAY}) => {\n  return axis === \"y\"\n    ? verge.inY(el, leeway) || verge.inY(el, -leeway)\n    : axis === \"x\"\n      ? verge.inX(el, leeway) || verge.inX(el, -leeway)\n      : verge.inViewport(el, leeway) || verge.inViewport(el, -leeway);\n};\n\nexport const makeClassName = pageNum => [\n  classes.page,\n  pageNum % 2 === 0 ? classes.pageEven : classes.pageOdd\n].join(\" \");","import m from \"mithril\";\nimport { getElementSize, makeClassName } from \"./util\";\n\nconst getPageData = url => {\n  return m.request({\n    method: \"GET\",\n    url,\n    initialValue: [],\n    background: true\n  });\n};\n\nexport const page = {};\n\npage.controller = (opts = {}) => {\n  const pageNum = opts.pageNum;\n  let content = m.prop([]);\n  if (opts.pageData) {\n    const result = opts.pageData(pageNum);\n    if (result.then) {\n      // A Promise\n      result.then((r) => {\n        content(r);\n      });\n    } else {\n      content = result;\n    }\n  } else if (opts.pageUrl) {\n    const url = opts.pageUrl(pageNum);\n    getPageData(url).then(data => (\n      content(data),\n      m.redraw()\n    ));\n  }\n\n  return {\n    content,\n    // Memoize some properties that do not change\n    className: makeClassName(pageNum),\n    pageTag: opts.pageTag || \"div\"\n  };\n};\n\npage.view = (ctrl, opts = {}) => {\n  const pageId = opts.pageId;\n  const storedPageSize = opts.pageSizes[pageId] || 0;\n\n  // pageSize overrides all measurements on elements here\n  let pageSize = 0;\n  if (opts.pageSize) {\n    pageSize = opts.pageSize(ctrl.content());\n    opts.updatePageSize(pageId, pageSize);\n  }\n  const cssSize = pageSize\n    ? pageSize + \"px\"\n    : !opts.autoSize || (opts.isScrolling && storedPageSize)\n      ? storedPageSize + \"px\"\n      : \"auto\";\n  const processPageData = opts.processPageData || ((content, opts1) =>\n    content\n      ? content.map((data, index) => opts.item(data, opts1, index))\n      : null\n  );\n\n  return m(ctrl.pageTag, {\n    \"data-page\": pageId,\n    class: ctrl.className,\n    style: storedPageSize\n      ? Object.assign(\n        {},\n        opts.axis === \"x\"\n          ? { width: cssSize }\n          : { height: cssSize }\n      )\n      : {},\n    config: pageSize\n      ? null\n      : el => {\n        // always update the natural size\n        const size = getElementSize(el, opts.axis);\n        if (size) {\n          opts.updatePageSize(pageId, size);\n        }\n        if (!storedPageSize) {\n          // this is the very first measurement\n          // make sure we use the first page size by calling the view again\n          setTimeout(m.redraw, 0);\n        }\n      }\n  }, processPageData(ctrl.content(), opts));\n};\n\n\n","import m from \"mithril\";\nimport { makeClassName } from \"./util\";\n\nexport const placeholder = {};\n\nplaceholder.controller = (opts = {}) => {\n  // Memoize some properties that do not change\n  return {\n    className: makeClassName(opts.pageNum)\n  };\n};\n\nplaceholder.view = (ctrl, opts = {}) => {\n  const pageId = opts.pageId;\n  const storedPageSize = opts.pageSizes[pageId] || 0;\n  return m(\"div\", {\n    \"data-page\": pageId,\n    class: ctrl.className,\n    style: Object.assign(\n      {},\n      opts.axis === \"x\"\n        ? { width:  storedPageSize + \"px\" }\n        : { height: storedPageSize + \"px\" }\n    )\n  });\n};\n","import J2c from \"j2c\";\nconst j2c = new J2c();\n\n/*\n * @param id: identifier, used as HTMLElement id for the attached <style></style> element\n * @param styles: list of lists style Objects\n */\nexport const addStyle = (id, ...styles) => {\n  removeStyle(id);\n  const styleEl = document.createElement(\"style\");\n  if (id) {\n    styleEl.setAttribute(\"id\", id);\n  }\n  styles.forEach((styleList) => {\n    // each style returns a list\n    if (Object.keys(styleList).length) {\n      styleList.forEach((style) => {\n        const scoped = { \"@global\": style };\n        const sheet = j2c.sheet(scoped);\n        styleEl.appendChild(document.createTextNode(sheet));\n      });\n    }\n  });\n  document.head.appendChild(styleEl);\n};\n\nconst removeStyle = id => {\n  if (id) {\n    const old = document.getElementById(id);\n    if (old) {\n      old.parentNode.removeChild(old);\n    }\n  }\n};","import { addStyle } from \"./styler\";\nimport { classes } from \"./classes\";\n\nconst styles = [{\n  [\".\" + classes.scrollView]: {\n    \"-webkit-overflow-scrolling\": \"touch\",\n    height: \"100%\",\n\n    [\"&.\" + classes.scrollViewY]: {\n      overflowX: \"hidden\",\n      overflowY: \"auto\",\n      height: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        height: \"100%\"\n      }\n    },\n\n    [\"&.\" + classes.scrollViewX]: {\n      overflowX: \"auto\",\n      overflowY: \"hidden\",\n      width: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        width: \"100%\"\n      }\n    }\n  }\n  // by default unstyled:\n  // mithril-infinite__content\n  // mithril-infinite__pages\n  // mithril-infinite__page\n}];\n\naddStyle(\"mithril-infinite\", styles);\n","import m from \"mithril\";\nimport { classes } from \"./classes\";\nimport { getElementSize, isElementInViewport } from \"./util\";\nimport { page } from \"./page\";\nimport { placeholder } from \"./placeholder\";\nimport \"./css\";\n\nconst SCROLL_WATCH_TIMER = 200;\nconst SEL_PADDING = \"000000\";\n\nconst numToId = pageNum =>\n  SEL_PADDING.substring(0, SEL_PADDING.length - (\"\" + pageNum).length) + pageNum;\n\nconst calculateCurrentPageNum = (scrollAmount, state) => {\n  const pageNumKeys = state.sortedKeys;\n  let acc = state.beforeSize || 0;\n  let currentPageNum = 1;\n  for (let i = 0; i < pageNumKeys.length; i = i + 1) {\n    let pageKey = pageNumKeys[i];\n    if (scrollAmount > acc) {\n      currentPageNum = parseInt(pageKey, 10);\n    }\n    acc += state.pageSizes[pageKey];\n  }\n  return currentPageNum;\n};\n\nconst calculateContentSize = (from, to, state) => {\n  const fromIndex = Math.max(0, from - 1);\n  if (to < fromIndex) {\n    return 0;\n  }\n  const toIndex = to;\n  const pageNumKeys = state.sortedKeys.slice(fromIndex, toIndex);\n  let size = state.beforeSize || 0;\n  size = pageNumKeys.reduce((total, pageKey) => (\n    total += state.pageSizes[pageKey] || 0\n  ), size);\n  size += state.afterSize || 0;\n  return size;\n};\n\nconst isPageInViewport = (page, axis, state, scrollView) => {\n  if (!scrollView) {\n    return false;\n  }\n  const id = numToId(page);\n  const el = scrollView.querySelector(\"[data-page=\\\"\" + id + \"\\\"]\");\n  return isElementInViewport({ el, axis });\n};\n\nconst updatePageSize = ctrl => (pageId, size) => (\n  ctrl.state.pageSizes[pageId] = size,\n  ctrl.state.sortedKeys = Object.keys(ctrl.state.pageSizes).sort()\n);\n\nexport const infinite = {};\n\ninfinite.controller = (opts) => {\n  // Memoize some properties that do not change\n  const whichScroll = opts.axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n  const maxPages = opts.maxPages !== undefined ? opts.maxPages : Number.MAX_VALUE;\n  const autoSize = (opts.autoSize !== undefined && opts.autoSize === false) ? false : true;\n  const scrollThrottle = opts.throttle !== undefined ? opts.throttle * 1000 : SCROLL_WATCH_TIMER;\n  const contentTag = opts.contentTag || \"div\";\n\n  return {\n    state: {\n      pageSizes: {},\n      sortedKeys: [],\n      beforeSize: null,\n      afterSize: null\n    },\n    scrollView: null,\n    isScrolling: false,\n    scrollWatchScrollingStateId: null,\n    scrollWatchUpdateStateId: null,\n    preloadSlots: opts.preloadPages || 1,\n    boundingClientRect: {},\n    currentPageNum: 0,\n    scrollAmount: 0,\n\n    // Memoized\n    whichScroll,\n    maxPages,\n    autoSize,\n    scrollThrottle,\n    contentTag\n  };\n};\n\ninfinite.view = (ctrl, opts) => {\n  const state = ctrl.state;\n  ctrl.scrollAmount = ctrl.scrollView ? ctrl.scrollView[ctrl.whichScroll] : 0;\n  \n  const currentPageNum = opts.currentPage\n    ? parseInt(opts.currentPage, 10)\n    : calculateCurrentPageNum(ctrl.scrollAmount, state);\n\n  if (currentPageNum !== ctrl.currentPageNum && opts.pageChange) {\n    opts.pageChange(currentPageNum);\n  }\n  ctrl.currentPageNum = currentPageNum;\n\n  if (ctrl.scrollView && opts.getDimensions) {\n    opts.getDimensions({\n      scrolled: ctrl.scrollAmount,\n      size: ctrl.contentSize\n    });\n  }\n\n  const minPageNum = opts.from\n    ? parseInt(opts.from, 10)\n    : opts.currentPage\n      ? opts.currentPage\n      : 1;\n  const maxPageNum = opts.to\n    ? parseInt(opts.to, 10)\n    : opts.currentPage\n      ? opts.currentPage\n      : ctrl.maxPages;\n  const pages = [];\n  const prePages = [];\n  for (let i = -ctrl.preloadSlots; i <= ctrl.preloadSlots; i = i + 1) {\n    const pageNum = currentPageNum + i;\n    if (pageNum >= minPageNum && pageNum <= maxPageNum) {\n      pages.push(pageNum);\n    }\n  }\n  for (let pageNum = 1; pageNum < pages[0]; pageNum = pageNum + 1) {\n    prePages.push(pageNum);\n  }\n\n  const classList = [\n    classes.scrollView,\n    opts.axis === \"x\"\n      ? classes.scrollViewX\n      : classes.scrollViewY,\n    opts.class\n  ].join(\" \");\n  ctrl.contentSize = calculateContentSize(1, maxPageNum, state);\n  const isLastPageVisible = maxPageNum\n    ? isPageInViewport(maxPageNum, opts.axis, state, ctrl.scrollView)\n    : true;\n\n  if (ctrl.scrollView) {\n    // in case the screen size was changed, reset preloadSlots\n    const boundingClientRect = ctrl.scrollView.getBoundingClientRect();\n    ctrl.boundingClientRect = ctrl.boundingClientRect || boundingClientRect;\n    if (boundingClientRect.width !== ctrl.boundingClientRect.width\n      || boundingClientRect.height !== ctrl.boundingClientRect.height\n    ) {\n      ctrl.preloadSlots = opts.preloadPages || 1;\n    }\n    ctrl.boundingClientRect = boundingClientRect;\n    // calculate if we have room to load more\n    const maxSlots = opts.maxPreloadPages || Number.MAX_VALUE;\n\n    if (ctrl.contentSize\n      && (ctrl.preloadSlots < pages.length)\n      && (ctrl.preloadSlots <= maxSlots)\n      && (ctrl.contentSize < boundingClientRect.height)\n    ) {\n      ctrl.preloadSlots++;\n      setTimeout(m.redraw, 0);\n    }\n  }\n\n  return m(\"div\", {\n    config: (el, inited, context) => {\n      if (inited) {\n        return;\n      }\n      if (opts.scrollView) {\n        ctrl.scrollView = document.querySelector(opts.scrollView);\n      } else {\n        ctrl.scrollView = el;\n      }\n      ctrl.scrollView.className += \" \" + classList;\n\n      if (opts.setDimensions) {\n        const dimensions = opts.setDimensions();\n        const whichSize = opts.axis === \"x\"\n          ? \"width\"\n          : \"height\";\n        if (dimensions.size > 0) {\n          el.style[whichSize] = dimensions.size + \"px\";\n        }\n        ctrl.scrollView[ctrl.whichScroll] = dimensions.scrolled;\n      }\n\n      const handleScroll = () => {\n        ctrl.isScrolling = true;\n\n        // reset isScrolling state only when scrolling is done\n        clearTimeout(ctrl.scrollWatchScrollingStateId);\n        ctrl.scrollWatchScrollingStateId = setTimeout(() => {\n          ctrl.isScrolling = false;\n          // update pages\n          m.redraw();\n        }, ctrl.scrollThrottle);\n\n        // throttle updates while scrolling\n        if (!ctrl.scrollWatchUpdateStateId) {\n          ctrl.scrollWatchUpdateStateId = setTimeout(() => {\n            // update pages\n            m.redraw();\n            ctrl.scrollWatchUpdateStateId = null;\n          }, ctrl.scrollThrottle);\n        }\n      };\n      ctrl.scrollView.addEventListener(\"scroll\", handleScroll);\n      context.onunload = () => {\n        ctrl.scrollView.removeEventListener(\"scroll\", handleScroll);\n      };\n    }\n  }, m(\"div\", {\n    class: classes.scrollContent,\n    style: !ctrl.autoSize\n      ? {}\n      : Object.assign(\n        {},\n        opts.axis === \"x\"\n          ? { width: ctrl.contentSize + \"px\" }\n          : { height: ctrl.contentSize + \"px\" },\n        opts.contentSize\n          ? opts.axis === \"x\"\n            ? { \"min-width\": opts.contentSize + \"px\" }\n            : { \"min-height\": opts.contentSize + \"px\" }\n          : {}\n    )\n  }, [\n    m(ctrl.contentTag, { class: classes.content }, [\n      opts.before\n        ? m(\"div\", {\n          class: classes.before,\n          config: el => {\n            // always update the natural size\n            const size = getElementSize(el, opts.axis);\n            if (size) {\n              state.beforeSize = size;\n            }\n          }\n        }, opts.before)\n        : null,\n      m(\"div\", { class: classes.pages }, [\n        prePages.map(pageNum => \n          m(placeholder, Object.assign(\n            {},\n            opts,\n            {\n              pageNum,\n              pageId: numToId(pageNum),\n              pageSizes: state.pageSizes\n            }\n          ))\n        ),\n        pages.map(pageNum =>\n          m(page, Object.assign(\n            {},\n            opts,\n            {\n              pageNum,\n              pageId: numToId(pageNum),\n              isScrolling: ctrl.isScrolling,\n              pageSizes: state.pageSizes,\n              updatePageSize: updatePageSize(ctrl),\n              autoSize: ctrl.autoSize\n            }\n          ))\n        )\n      ]),\n      // only show \"after\" when content is available\n      opts.after && ctrl.contentSize\n        ? m(\"div\", {\n          class: classes.after,\n          style: {\n            // visually hide this element until the last page is into view\n            // to prevent flashes of after content when scrolling fast\n            visibility: isLastPageVisible ? \"visible\" : \"hidden\"\n          },\n          config: el => {\n            // always update the natural size\n            const size = getElementSize(el, opts.axis);\n            if (size) {\n              state.afterSize = size;\n            }\n          }\n        }, opts.after)\n        : null\n    ])\n  ]));\n};\n\ninfinite.isElementInViewport = isElementInViewport;\n\n"],"names":["defaults","target","source","k","own","call","indexOf","cartesian","a","b","i","j","res","push","splitSelector","selector","o","indices","inParen","selectorTokenizer","exec","index","length","unshift","slice","ampersand","parents","split","ampersandTokenizer","join","flatIter","f","iter","arg","type","ARRAY","randChars","n","chars","Math","floor","random","toString","decamelize","match","toLowerCase","declarations","state","emit","prefix","local","v","kk","valueOf","OBJECT","test","raw","replace","map","localizeReplacer","decl","atRules","nestingDepth","atruleHandlers","err","JSON","stringify","adoptee","asString","localize","names","atrule","_atrule","rules","tree","inDeclaration","rule","_rule","STRING","closeSelectors","next","inline","lastSelector","init","done","kind","param","takesBlock","invoke","fn","backend","e","Error","stack","makeInstance","suffix","nsCache","setPropList","name","ignore","global","dot","instance","J2c","options","buf","_backend","msg","str","prop","value","_filters","_atruleHandlers","_setPropList","_suffix","_nsCache","plugins","plugin","filter","FUNCTION","sink","set","NUMBER","freeze","classes","root","make","module","this","viewport","width","viewportW","height","viewportH","calibrate","coords","cushion","rectangle","el","nodeType","getBoundingClientRect","aspect","h","w","xports","win","window","doc","document","docElem","documentElement","matchMedia","mq","q","matches","apply","arguments","pageXOffset","scrollLeft","pageYOffset","scrollTop","r","right","left","bottom","top","LEEWAY","getElementSize","axis","styles","getComputedStyle","margin","parseFloat","marginLeft","marginRight","scrollWidth","marginTop","marginBottom","scrollHeight","isElementInViewport","leeway","verge","inY","inX","inViewport","makeClassName","page","pageNum","pageEven","pageOdd","getPageData","m","request","controller","opts","content","pageData","result","then","pageUrl","url","data","redraw","pageTag","view","ctrl","pageId","storedPageSize","pageSizes","pageSize","updatePageSize","cssSize","autoSize","isScrolling","processPageData","opts1","item","className","babelHelpers.extends","size","placeholder","emptyObject","hasOwnProperty","Object","j2c","addStyle","id","styleEl","createElement","setAttribute","forEach","styleList","keys","style","scoped","@global","sheet","appendChild","createTextNode","head","removeStyle","old","getElementById","parentNode","removeChild","scrollView","scrollViewY","scrollContent","scrollViewX","SCROLL_WATCH_TIMER","SEL_PADDING","numToId","substring","calculateCurrentPageNum","scrollAmount","pageNumKeys","sortedKeys","acc","beforeSize","currentPageNum","pageKey","parseInt","calculateContentSize","from","to","fromIndex","max","toIndex","reduce","total","afterSize","isPageInViewport","querySelector","sort","infinite","whichScroll","maxPages","undefined","Number","MAX_VALUE","scrollThrottle","throttle","contentTag","preloadPages","currentPage","pageChange","getDimensions","contentSize","minPageNum","maxPageNum","pages","prePages","preloadSlots","classList","class","isLastPageVisible","boundingClientRect","maxSlots","maxPreloadPages","inited","context","setDimensions","dimensions","whichSize","scrolled","handleScroll","scrollWatchScrollingStateId","setTimeout","scrollWatchUpdateStateId","addEventListener","onunload","removeEventListener","min-width","min-height","before","after"],"mappings":"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"}