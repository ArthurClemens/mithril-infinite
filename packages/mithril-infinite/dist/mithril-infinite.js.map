{"version":3,"file":"mithril-infinite.js","sources":["../src/classes.js","../src/util.js","../src/page.js","../src/placeholder.js","../src/styler.js","../src/css.js","../src/index.js"],"sourcesContent":["\nexport const classes = {\n  scrollView:    \"mithril-infinite__scroll-view\",\n  scrollViewX:   \"mithril-infinite__scroll-view--x\",\n  scrollViewY:   \"mithril-infinite__scroll-view--y\",\n  scrollContent: \"mithril-infinite__scroll-content\",\n  content:       \"mithril-infinite__content\",\n  pages:         \"mithril-infinite__pages\",\n  page:          \"mithril-infinite__page\",\n  pageEven:      \"mithril-infinite__page--even\",\n  pageOdd:       \"mithril-infinite__page--odd\",\n  placeholder:   \"mithril-infinite__page--placeholder\",\n  before:        \"mithril-infinite__before\",\n  after:         \"mithril-infinite__after\"\n};\n","import verge from \"verge\";\nimport { classes } from \"./classes\";\n\nconst LEEWAY = 300;\n\nexport const getElementSize = (el, axis) => {\n  const styles = window.getComputedStyle(el);\n  if (axis === \"x\") {\n    const margin = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    return el.scrollWidth + margin;\n  } else {\n    const margin = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    return el.scrollHeight + margin;\n  }\n};\n\n// el, axis = \"y\", expand = LEEWAY\nexport const isElementInViewport = ({el, axis = \"y\", leeway = LEEWAY}) => {\n  return axis === \"y\"\n    ? verge.inY(el, leeway) || verge.inY(el, -leeway)\n    : axis === \"x\"\n      ? verge.inX(el, leeway) || verge.inX(el, -leeway)\n      : verge.inViewport(el, leeway) || verge.inViewport(el, -leeway);\n};\n\nexport const makeClassName = pageNum => [\n  classes.page,\n  pageNum % 2 === 0 ? classes.pageEven : classes.pageOdd\n].join(\" \");","import m from \"mithril\";\nimport stream from \"mithril/stream\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport { getElementSize, makeClassName } from \"./util\";\n\nconst getPageData = url =>\n  m.request({\n    method: \"GET\",\n    url\n  });\n\nconst oninit = ({ state, attrs }) => {\n  const pageNum = attrs.pageNum;\n  let content = stream([]);\n\n  if (attrs.pageData) {\n    const result = attrs.pageData(pageNum);\n    Promise.resolve(result).then(content).then(m.redraw);\n  } else if (attrs.pageUrl) {\n    const url = attrs.pageUrl(pageNum);\n    getPageData(url).then(content);\n  }\n\n  const processPageData = attrs.processPageData || ((content, attrs1) =>\n    content && content.length\n      ? content.map((data, index) => attrs.item(data, attrs1, index))\n      : null\n  );\n\n  state.content = content;\n  // Memoize some properties that do not change\n  state.className = makeClassName(pageNum);\n  state.pageTag = attrs.pageTag || \"div\";\n  state.processPageData = processPageData;\n};\n\nconst view = ({ state, attrs }) => {\n  const pageId = attrs.pageId;\n  const storedPageSize = attrs.pageSizes[pageId] || 0;\n  let pageSize = 0;\n\n  // attrs/pageSize overrides all measurements on elements here\n  if (attrs.pageSize) {\n    pageSize = attrs.pageSize(state.content());\n    attrs.updatePageSize(pageId, pageSize);\n  }\n\n  const cssSize = pageSize\n    ? pageSize + \"px\"\n    : !attrs.autoSize\n      ? storedPageSize + \"px\"\n      : \"auto\";\n\n  const update = dom => {\n    if (pageSize) return;\n    const size = getElementSize(dom, attrs.axis);\n    if (size) {\n      attrs.updatePageSize(pageId, size);\n    }\n  };\n\n  return m(state.pageTag, {\n    \"data-page\": pageId,\n    class: state.className,\n    style: storedPageSize\n      ? attrs.axis === \"x\"\n        ? { width: cssSize }\n        : { height: cssSize }\n      : null,\n    oncreate: ({ dom }) => {\n      const ro = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect;\n          if (\n            (attrs.axis === \"x\" && width !== storedPageSize)\n            || (attrs.axis === \"y\" && height !== storedPageSize)\n          ) {\n            update(dom);\n          }\n        }\n      });\n      ro.observe(dom);\n      // update(dom);\n    },\n    onupdate: ({ dom }) => update(dom)\n  }, state.processPageData(state.content(), {\n    pageId: attrs.pageId,\n    pageNum: attrs.pageNum\n  }));\n};\n\nexport const page = {\n  oninit,\n  view\n};\n","import m from \"mithril\";\nimport { makeClassName } from \"./util\";\nimport { classes } from \"./classes\";\n\nexport const placeholder = {\n  oninit: vnode =>\n    // Memoize some properties that do not change\n    vnode.state.className = makeClassName(vnode.attrs.pageNum),\n  view: ({ state, attrs }) => {\n    const pageId = attrs.pageId;\n    const storedPageSize = attrs.pageSizes[pageId] || 0;\n\n    return m(\"div\", {\n      \"data-page\": pageId,\n      class: [\n        classes.placeholder,\n        state.className\n      ].join(\" \"),\n      style: Object.assign(\n        {},\n        attrs.axis === \"x\"\n          ? { width:  storedPageSize + \"px\" }\n          : { height: storedPageSize + \"px\" }\n      )\n    });\n  }\n};\n","import J2c from \"j2c\";\nconst j2c = new J2c();\n\n/*\n * @param id: identifier, used as HTMLElement id for the attached <style></style> element\n * @param styles: list of lists style Objects\n */\nexport const addStyle = (id, ...styles) => {\n  removeStyle(id);\n  const styleEl = document.createElement(\"style\");\n  if (id) {\n    styleEl.setAttribute(\"id\", id);\n  }\n  styles.forEach((styleList) => {\n    // each style returns a list\n    if (Object.keys(styleList).length) {\n      styleList.forEach((style) => {\n        const scoped = { \"@global\": style };\n        const sheet = j2c.sheet(scoped);\n        styleEl.appendChild(document.createTextNode(sheet));\n      });\n    }\n  });\n  document.head.appendChild(styleEl);\n};\n\nconst removeStyle = id => {\n  if (id) {\n    const old = document.getElementById(id);\n    if (old) {\n      old.parentNode.removeChild(old);\n    }\n  }\n};","import { addStyle } from \"./styler\";\nimport { classes } from \"./classes\";\n\nconst styles = [{\n  [\".\" + classes.scrollView]: {\n    \"-webkit-overflow-scrolling\": \"touch\",\n    height: \"100%\",\n\n    [\" .\" + classes.scrollContent]: {\n      overflowAnchor: \"none\",\n    },\n\n    [\"&.\" + classes.scrollViewY]: {\n      overflowX: \"hidden\",\n      overflowY: \"auto\",\n      height: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        height: \"100%\",\n      }\n    },\n\n    [\"&.\" + classes.scrollViewX]: {\n      overflowX: \"auto\",\n      overflowY: \"hidden\",\n      width: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        width: \"100%\"\n      }\n    }\n  }\n  // by default unstyled:\n  // mithril-infinite__content\n  // mithril-infinite__pages\n  // mithril-infinite__page\n}];\n\naddStyle(\"mithril-infinite\", styles);\n","import m from \"mithril\";\nimport { classes } from \"./classes\";\nimport { getElementSize, isElementInViewport } from \"./util\";\nimport { page } from \"./page\";\nimport { placeholder } from \"./placeholder\";\nimport \"./css\";\n\nconst SEL_PADDING = \"000000\";\n\nconst numToId = pageNum =>\n  SEL_PADDING.substring(0, SEL_PADDING.length - (\"\" + pageNum).length) + pageNum;\n\nconst calculateCurrentPageNum = (scrollAmount, state) => {\n  const pageNumKeys = state.sortedKeys;\n  if (pageNumKeys.length === 0) {\n    return 1;\n  }\n  let acc = state.beforeSize || 0;\n  let currentPageNum = 1;\n  for (let i = 0; i < pageNumKeys.length; i = i + 1) {\n    let pageKey = pageNumKeys[i];\n    if (scrollAmount > acc) {\n      currentPageNum = parseInt(pageKey, 10);\n    }\n    acc += state.pageSizes[pageKey];\n  }\n  return currentPageNum;\n};\n\nconst calculateContentSize = (from, to, state) => {\n  const fromIndex = Math.max(0, from - 1);\n  if (to < fromIndex) {\n    return 0;\n  }\n  const toIndex = to;\n  const pageNumKeys = state.sortedKeys.slice(fromIndex, toIndex);\n  let size = state.beforeSize || 0;\n  size = pageNumKeys.reduce((total, pageKey) => (\n    total += state.pageSizes[pageKey] || 0\n  ), size);\n  size += state.afterSize || 0;\n  return size;\n};\n\nconst isPageInViewport = (page, axis, state, scrollView) => {\n  if (!scrollView) {\n    return false;\n  }\n  const id = numToId(page);\n  const el = scrollView.querySelector(`[data-page=\"${id}\"]`);\n  return isElementInViewport({ el, axis });\n};\n\nconst updatePageSize = state => (pageId, size) => {\n  const oldSize = state.pageSizes[pageId];\n  const newSize = parseInt(size, 10);\n  if (oldSize !== newSize) {\n    state.pageSizes[pageId] = newSize;\n    state.sortedKeys = Object.keys(state.pageSizes).sort();\n    calculatePreloadSlots(state);\n    setTimeout(m.redraw, 0);\n  }\n};\n\nconst updatePart = (dom, whichSize, state, axis) => {\n  const size = getElementSize(dom, axis);\n  if (size) {\n    state[whichSize] = size;\n  }\n};\n\nconst calculatePreloadSlots = state => {\n  if (!state.scrollView) return;\n  const boundingClientRect = state.scrollView.getBoundingClientRect();\n  state.boundingClientRect = state.boundingClientRect || boundingClientRect;\n  if (boundingClientRect.width !== state.boundingClientRect.width\n    || boundingClientRect.height !== state.boundingClientRect.height\n  ) {\n    state.preloadSlots = state.attrsPreloadSlots || 1;\n  }\n  state.boundingClientRect = boundingClientRect;\n\n  // calculate if we have room on the screen to show more slots\n  if (state.contentSize\n    && (state.preloadSlots < state.pageCount)\n    && (state.preloadSlots <= state.attrsMaxPreloadSlots)\n    && (state.contentSize < boundingClientRect.height)\n  ) {\n    state.preloadSlots++;\n    setTimeout(m.redraw, 0);\n  }\n};\n\nconst getPageList = (currentPageNum, fromPage, toPage, currentPage, preloadSlots, maxPages) => {\n  const minPageNum = fromPage\n    ? parseInt(fromPage, 10)\n    : currentPage\n      ? currentPage\n      : 1;\n  const maxPageNum = toPage\n    ? parseInt(toPage, 10)\n    : currentPage\n      ? currentPage\n      : maxPages;\n  const pages = [];\n  const prePages = [];\n  for (let i = -preloadSlots; i <= preloadSlots; i = i + 1) {\n    const pageNum = currentPageNum + i;\n    if (pageNum >= minPageNum && pageNum <= maxPageNum) {\n      pages.push(pageNum);\n    }\n  }\n  for (let pageNum = 1; pageNum < pages[0]; pageNum = pageNum + 1) {\n    prePages.push(pageNum);\n  }\n  return {pages, prePages, maxPageNum};\n};\n\nconst oninit = vnode => {\n  const attrs = vnode.attrs;\n  // Memoize some properties that do not change\n  const axis = attrs.axis || \"y\";\n  const whichScroll = axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n  const autoSize = (attrs.autoSize !== undefined && attrs.autoSize === false) ? false : true;\n  const pageSize = attrs.pageSize;\n  const contentTag = attrs.contentTag || \"div\";\n  const classList = [\n    classes.scrollView,\n    axis === \"x\"\n      ? classes.scrollViewX\n      : classes.scrollViewY,\n    attrs.class\n  ].join(\" \");\n\n  const scroll = () => m.redraw();\n\n  vnode.state = {\n    afterSize: null,\n    beforeSize: null,\n    boundingClientRect: {},\n    currentPageNum: 0,\n    pageSizes: {},\n    preloadSlots: attrs.preloadPages || 1,\n    scrollView: null,\n    sortedKeys: [],\n\n    // Memoized\n    attrsMaxPreloadSlots: attrs.maxPreloadPages || Number.MAX_VALUE,\n    attrsPreloadSlots: attrs.preloadPages || 1,\n    autoSize,\n    axis,\n    classList,\n    contentTag,\n    pageSize,\n    scroll,\n    whichScroll,\n  };\n};\n\nconst view = ({ state, attrs }) => {\n  const scrollAmount = state.scrollView ? state.scrollView[state.whichScroll] : 0;\n  const axis = state.axis;\n  const maxPages = attrs.maxPages !== undefined ? attrs.maxPages : Number.MAX_VALUE;\n  \n  const currentPageNum = attrs.currentPage\n    ? parseInt(attrs.currentPage, 10)\n    : calculateCurrentPageNum(scrollAmount, state);\n\n  if (attrs.pageChange && currentPageNum !== state.currentPageNum) {\n    attrs.pageChange(currentPageNum);\n  }\n  state.currentPageNum = currentPageNum;\n\n  if (state.scrollView && attrs.getDimensions) {\n    attrs.getDimensions({\n      scrolled: scrollAmount,\n      size: state.contentSize\n    });\n  }\n\n  const { pages, prePages, maxPageNum } = getPageList(currentPageNum, attrs.from, attrs.to, attrs.currentPage, state.preloadSlots, maxPages);\n  state.contentSize = attrs.contentSize !== undefined\n    ? attrs.contentSize\n    : calculateContentSize(1, maxPageNum, state);\n\n  state.pageCount = pages.length;\n\n  const isLastPageVisible = maxPageNum\n    ? isPageInViewport(maxPageNum, axis, state, state.scrollView)\n    : true;\n  \n  return m(\"div\",\n    {\n      oncreate: ({ dom }) => {\n        state.scrollView = attrs.scrollView\n          ? document.querySelector(attrs.scrollView)\n          : dom;\n        state.scrollView.className += \" \" + state.classList;\n\n        if (attrs.setDimensions) {\n          const dimensions = attrs.setDimensions();\n          if (dimensions.size > 0) {\n            const whichSize = axis === \"x\"\n              ? \"width\"\n              : \"height\";\n            dom.style[whichSize] = dimensions.size + \"px\";\n          }\n          state.scrollView[state.whichScroll] = dimensions.scrolled;\n        }\n        state.scrollView.addEventListener(\"scroll\", state.scroll);\n      },\n      onremove: () => state.scrollView.removeEventListener(\"scroll\", state.scroll)\n    },\n    m(\"div\",\n      {\n        class: classes.scrollContent,\n        style: !state.autoSize\n          ? null\n          : Object.assign(\n            {},\n            axis === \"x\"\n              ? { width: state.contentSize + \"px\" }\n              : { height: state.contentSize + \"px\" },\n            attrs.contentSize\n              ? axis === \"x\"\n                ? { \"min-width\": attrs.contentSize + \"px\" }\n                : { \"min-height\": attrs.contentSize + \"px\" }\n              : {}\n          )\n      },\n      [\n        m(state.contentTag, { class: classes.content }, [\n          attrs.before\n            ? m(\"div\", {\n              class: classes.before,\n              oncreate: ({ dom }) => updatePart(dom, \"before\", state, axis),\n              onupdate: ({ dom }) => updatePart(dom, \"before\", state, axis)\n            }, attrs.before)\n            : null,\n          m(\"div\", { class: classes.pages }, [\n            prePages.map(pageNum => \n              m(placeholder, {\n                axis,\n                key: (attrs.pageKey || numToId)(pageNum),\n                pageId: numToId(pageNum),\n                pageNum,\n                pageSizes: state.pageSizes\n              })\n            ),\n            pages.map(pageNum =>\n              m(page, {\n                autoSize: state.autoSize,\n                axis,\n                item: attrs.item,\n                key: (attrs.pageKey || numToId)(pageNum),\n                pageData: attrs.pageData,\n                pageId: numToId(pageNum),\n                pageNum,\n                pageSize: state.pageSize,\n                pageSizes: state.pageSizes,\n                pageTag: attrs.pageTag,\n                pageUrl: attrs.pageUrl,\n                updatePageSize: updatePageSize(state)\n              })\n            )\n          ]),\n          // only show \"after\" when content is available\n          attrs.after && state.contentSize\n            ? m(\"div\", {\n              class: classes.after,\n              style: {\n                // visually hide this element until the last page is into view\n                // to prevent flashes of after content when scrolling fast\n                visibility: isLastPageVisible ? \"visible\" : \"hidden\"\n              },\n              oncreate: ({ dom }) => updatePart(dom, \"after\", state, axis),\n              onupdate: ({ dom }) => updatePart(dom, \"after\", state, axis),\n            }, attrs.after)\n            : null\n        ])\n      ]\n    )\n  );\n};\n\nexport const infinite = {\n  oninit,\n  view,\n  isElementInViewport\n};\n\n"],"names":["classes","scrollView","scrollViewX","scrollViewY","scrollContent","content","pages","page","pageEven","pageOdd","placeholder","before","after","getElementSize","el","axis","styles","window","getComputedStyle","margin","parseFloat","marginLeft","marginRight","scrollWidth","marginTop","marginBottom","scrollHeight","isElementInViewport","leeway","verge","inY","inX","inViewport","makeClassName","pageNum","join","oninit","state","attrs","stream","pageData","result","Promise","resolve","then","m","redraw","pageUrl","url","request","method","getPageData","processPageData","attrs1","length","map","data","index","item","className","pageTag","view","pageId","storedPageSize","pageSizes","pageSize","updatePageSize","cssSize","autoSize","update","dom","size","class","style","width","height","oncreate","ResizeObserver","entries","contentRect","observe","onupdate","vnode","_extends","j2c","J2c","removeStyle","id","old","document","getElementById","parentNode","removeChild","styleEl","createElement","setAttribute","forEach","styleList","Object","keys","scoped","sheet","appendChild","createTextNode","head","addStyle","overflowAnchor","overflowX","overflowY","numToId","substring","oldSize","newSize","parseInt","sortedKeys","sort","calculatePreloadSlots","setTimeout","updatePart","whichSize","boundingClientRect","getBoundingClientRect","preloadSlots","attrsPreloadSlots","contentSize","pageCount","attrsMaxPreloadSlots","whichScroll","undefined","contentTag","classList","afterSize","beforeSize","currentPageNum","preloadPages","maxPreloadPages","Number","MAX_VALUE","scroll","scrollAmount","maxPages","currentPage","pageNumKeys","acc","i","pageKey","calculateCurrentPageNum","pageChange","getDimensions","scrolled","fromPage","toPage","minPageNum","maxPageNum","prePages","push","getPageList","from","to","fromIndex","Math","max","toIndex","slice","reduce","total","calculateContentSize","isLastPageVisible","querySelector","isPageInViewport","setDimensions","dimensions","addEventListener","onremove","removeEventListener","key","visibility"],"mappings":"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"}