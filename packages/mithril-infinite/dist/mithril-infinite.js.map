{"version":3,"file":"mithril-infinite.js","sources":["../src/classes.js","../src/util.js","../node_modules/mithril/stream/stream.js","../node_modules/mithril/stream.js","../src/page.js","../src/placeholder.js","../src/styler.js","../src/css.js","../src/index.js"],"sourcesContent":["\nexport const classes = {\n  scrollView:    \"mithril-infinite__scroll-view\",\n  scrollViewX:   \"mithril-infinite__scroll-view--x\",\n  scrollViewY:   \"mithril-infinite__scroll-view--y\",\n  scrollContent: \"mithril-infinite__scroll-content\",\n  content:       \"mithril-infinite__content\",\n  pages:         \"mithril-infinite__pages\",\n  page:          \"mithril-infinite__page\",\n  pageEven:      \"mithril-infinite__page--even\",\n  pageOdd:       \"mithril-infinite__page--odd\",\n  placeholder:   \"mithril-infinite__page--placeholder\",\n  before:        \"mithril-infinite__before\",\n  after:         \"mithril-infinite__after\"\n};\n","import verge from \"verge\";\nimport { classes } from \"./classes\";\n\nconst LEEWAY = 300;\n\nexport const getElementSize = (el, axis) => {\n  const styles = window.getComputedStyle(el);\n  if (axis === \"x\") {\n    const margin = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    return el.scrollWidth + margin;\n  } else {\n    const margin = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    return el.scrollHeight + margin;\n  }\n};\n\n// el, axis = \"y\", expand = LEEWAY\nexport const isElementInViewport = ({el, axis = \"y\", leeway = LEEWAY}) => {\n  return axis === \"y\"\n    ? verge.inY(el, leeway) || verge.inY(el, -leeway)\n    : axis === \"x\"\n      ? verge.inX(el, leeway) || verge.inX(el, -leeway)\n      : verge.inViewport(el, leeway) || verge.inViewport(el, -leeway);\n};\n\nexport const makeClassName = pageNum => [\n  classes.page,\n  pageNum % 2 === 0 ? classes.pageEven : classes.pageOdd\n].join(\" \");","\"use strict\"\n\nvar guid = 0, HALT = {}\nfunction createStream() {\n\tfunction stream() {\n\t\tif (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])\n\t\treturn stream._state.value\n\t}\n\tinitStream(stream)\n\n\tif (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])\n\n\treturn stream\n}\nfunction initStream(stream) {\n\tstream.constructor = createStream\n\tstream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined}\n\tstream.map = stream[\"fantasy-land/map\"] = map, stream[\"fantasy-land/ap\"] = ap, stream[\"fantasy-land/of\"] = createStream\n\tstream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf\n\n\tObject.defineProperties(stream, {\n\t\tend: {get: function() {\n\t\t\tif (!stream._state.endStream) {\n\t\t\t\tvar endStream = createStream()\n\t\t\t\tendStream.map(function(value) {\n\t\t\t\t\tif (value === true) unregisterStream(stream), unregisterStream(endStream)\n\t\t\t\t\treturn value\n\t\t\t\t})\n\t\t\t\tstream._state.endStream = endStream\n\t\t\t}\n\t\t\treturn stream._state.endStream\n\t\t}}\n\t})\n}\nfunction updateStream(stream, value) {\n\tupdateState(stream, value)\n\tfor (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)\n\tfinalize(stream)\n}\nfunction updateState(stream, value) {\n\tstream._state.value = value\n\tstream._state.changed = true\n\tif (stream._state.state !== 2) stream._state.state = 1\n}\nfunction updateDependency(stream, mustSync) {\n\tvar state = stream._state, parents = state.parents\n\tif (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {\n\t\tvar value = stream._state.derive()\n\t\tif (value === HALT) return false\n\t\tupdateState(stream, value)\n\t}\n}\nfunction finalize(stream) {\n\tstream._state.changed = false\n\tfor (var id in stream._state.deps) stream._state.deps[id]._state.changed = false\n}\n\nfunction combine(fn, streams) {\n\tif (!streams.every(valid)) throw new Error(\"Ensure that each item passed to m.prop.combine/m.prop.merge is a stream\")\n\treturn initDependency(createStream(), streams, function() {\n\t\treturn fn.apply(this, streams.concat([streams.filter(changed)]))\n\t})\n}\n\nfunction initDependency(dep, streams, derive) {\n\tvar state = dep._state\n\tstate.derive = derive\n\tstate.parents = streams.filter(notEnded)\n\n\tregisterDependency(dep, state.parents)\n\tupdateDependency(dep, true)\n\n\treturn dep\n}\nfunction registerDependency(stream, parents) {\n\tfor (var i = 0; i < parents.length; i++) {\n\t\tparents[i]._state.deps[stream._state.id] = stream\n\t\tregisterDependency(stream, parents[i]._state.parents)\n\t}\n}\nfunction unregisterStream(stream) {\n\tfor (var i = 0; i < stream._state.parents.length; i++) {\n\t\tvar parent = stream._state.parents[i]\n\t\tdelete parent._state.deps[stream._state.id]\n\t}\n\tfor (var id in stream._state.deps) {\n\t\tvar dependent = stream._state.deps[id]\n\t\tvar index = dependent._state.parents.indexOf(stream)\n\t\tif (index > -1) dependent._state.parents.splice(index, 1)\n\t}\n\tstream._state.state = 2 //ended\n\tstream._state.deps = {}\n}\n\nfunction map(fn) {return combine(function(stream) {return fn(stream())}, [this])}\nfunction ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}\nfunction valueOf() {return this._state.value}\nfunction toJSON() {return this._state.value != null && typeof this._state.value.toJSON === \"function\" ? this._state.value.toJSON() : this._state.value}\n\nfunction valid(stream) {return stream._state }\nfunction active(stream) {return stream._state.state === 1}\nfunction changed(stream) {return stream._state.changed}\nfunction notEnded(stream) {return stream._state.state !== 2}\n\nfunction merge(streams) {\n\treturn combine(function() {\n\t\treturn streams.map(function(s) {return s()})\n\t}, streams)\n}\ncreateStream[\"fantasy-land/of\"] = createStream\ncreateStream.merge = merge\ncreateStream.combine = combine\ncreateStream.HALT = HALT\n\nif (typeof module !== \"undefined\") module[\"exports\"] = createStream\nelse window.stream = createStream\n","module.exports = require(\"./stream/stream\")","import m from \"mithril\";\nimport prop from \"mithril/stream\";\nimport { getElementSize, makeClassName } from \"./util\";\n\nconst getPageData = url =>\n  m.request({\n    method: \"GET\",\n    url\n  });\n\nconst oninit = ({ state, attrs }) => {\n  const pageNum = attrs.pageNum;\n  let content = prop([]);\n  if (attrs.pageData) {\n    const result = attrs.pageData(pageNum);\n    if (result.then) {\n      // A Promise\n      result.then(content);\n    } else {\n      content = result;\n    }\n  } else if (attrs.pageUrl) {\n    const url = attrs.pageUrl(pageNum);\n    getPageData(url).then(content);\n  }\n\n  const processPageData = attrs.processPageData || ((content, attrs1) =>\n    content && content.length\n      ? content.map((data, index) => attrs.item(data, attrs1, index))\n      : null\n  );\n\n  state.content = content;\n  // Memoize some properties that do not change\n  state.className = makeClassName(pageNum);\n  state.pageTag = attrs.pageTag || \"div\";\n  state.processPageData = processPageData;\n};\n\nconst view = ({state, attrs}) => {\n  const pageId = attrs.pageId;\n  const storedPageSize = attrs.pageSizes[pageId] || 0;\n  let pageSize = 0;\n\n  // attrs/pageSize overrides all measurements on elements here\n  if (attrs.pageSize) {\n    pageSize = attrs.pageSize(state.content());\n    attrs.updatePageSize(pageId, pageSize);\n  }\n\n  const cssSize = pageSize\n    ? pageSize + \"px\"\n    : !attrs.autoSize || (attrs.isScrolling && storedPageSize)\n      ? storedPageSize + \"px\"\n      : \"auto\";\n  const update = dom => {\n    if (pageSize) return;\n    const size = getElementSize(dom, attrs.axis);\n    if (size) {\n      attrs.updatePageSize(pageId, size);\n    }\n    if (!storedPageSize) {\n      // this is the very first measurement\n      // make sure we use the first page size by calling the view again\n      setTimeout(m.redraw, 0);\n    }\n  };\n\n  return m(state.pageTag, {\n    \"data-page\": pageId,\n    class: state.className,\n    style: storedPageSize\n      ? attrs.axis === \"x\"\n        ? { width: cssSize }\n        : { height: cssSize }\n      : null,\n    oncreate: ({ dom }) => update(dom),\n    onupdate: ({ dom }) => update(dom)\n  }, state.processPageData(state.content(), {\n    isScrolling: attrs.isScrolling,\n    pageId: attrs.pageId,\n    pageNum: attrs.pageNum\n  }));\n};\n\nexport const page = {\n  oninit,\n  view\n};\n","import m from \"mithril\";\nimport { makeClassName } from \"./util\";\nimport { classes } from \"./classes\";\n\nexport const placeholder = {\n  oninit: vnode =>\n    // Memoize some properties that do not change\n    vnode.state.className = makeClassName(vnode.attrs.pageNum),\n  view: ({state, attrs}) => {\n    const pageId = attrs.pageId;\n    const storedPageSize = attrs.pageSizes[pageId] || 0;\n    return m(\"div\", {\n      \"data-page\": pageId,\n      class: [\n        classes.placeholder,\n        state.className\n      ].join(\" \"),\n      style: Object.assign(\n        {},\n        attrs.axis === \"x\"\n          ? { width:  storedPageSize + \"px\" }\n          : { height: storedPageSize + \"px\" }\n      )\n    });\n  }\n};\n","import J2c from \"j2c\";\nconst j2c = new J2c();\n\n/*\n * @param id: identifier, used as HTMLElement id for the attached <style></style> element\n * @param styles: list of lists style Objects\n */\nexport const addStyle = (id, ...styles) => {\n  removeStyle(id);\n  const styleEl = document.createElement(\"style\");\n  if (id) {\n    styleEl.setAttribute(\"id\", id);\n  }\n  styles.forEach((styleList) => {\n    // each style returns a list\n    if (Object.keys(styleList).length) {\n      styleList.forEach((style) => {\n        const scoped = { \"@global\": style };\n        const sheet = j2c.sheet(scoped);\n        styleEl.appendChild(document.createTextNode(sheet));\n      });\n    }\n  });\n  document.head.appendChild(styleEl);\n};\n\nconst removeStyle = id => {\n  if (id) {\n    const old = document.getElementById(id);\n    if (old) {\n      old.parentNode.removeChild(old);\n    }\n  }\n};","import { addStyle } from \"./styler\";\nimport { classes } from \"./classes\";\n\nconst styles = [{\n  [\".\" + classes.scrollView]: {\n    \"-webkit-overflow-scrolling\": \"touch\",\n    height: \"100%\",\n\n    [\"&.\" + classes.scrollViewY]: {\n      overflowX: \"hidden\",\n      overflowY: \"auto\",\n      height: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        height: \"100%\"\n      }\n    },\n\n    [\"&.\" + classes.scrollViewX]: {\n      overflowX: \"auto\",\n      overflowY: \"hidden\",\n      width: \"100%\",\n\n      [\" .\" + classes.scrollContent]: {\n        width: \"100%\"\n      }\n    }\n  }\n  // by default unstyled:\n  // mithril-infinite__content\n  // mithril-infinite__pages\n  // mithril-infinite__page\n}];\n\naddStyle(\"mithril-infinite\", styles);\n","import m from \"mithril\";\nimport { classes } from \"./classes\";\nimport { getElementSize, isElementInViewport } from \"./util\";\nimport { page } from \"./page\";\nimport { placeholder } from \"./placeholder\";\nimport \"./css\";\n\nconst SCROLL_WATCH_TIMER = 200;\nconst SEL_PADDING = \"000000\";\n\nconst numToId = pageNum =>\n  SEL_PADDING.substring(0, SEL_PADDING.length - (\"\" + pageNum).length) + pageNum;\n\nconst calculateCurrentPageNum = (scrollAmount, state) => {\n  const pageNumKeys = state.sortedKeys;\n  if (pageNumKeys.length === 0) {\n    return 1;\n  }\n  let acc = state.beforeSize || 0;\n  let currentPageNum = 1;\n  for (let i = 0; i < pageNumKeys.length; i = i + 1) {\n    let pageKey = pageNumKeys[i];\n    if (scrollAmount > acc) {\n      currentPageNum = parseInt(pageKey, 10);\n    }\n    acc += state.pageSizes[pageKey];\n  }\n  return currentPageNum;\n};\n\nconst calculateContentSize = (from, to, state) => {\n  const fromIndex = Math.max(0, from - 1);\n  if (to < fromIndex) {\n    return 0;\n  }\n  const toIndex = to;\n  const pageNumKeys = state.sortedKeys.slice(fromIndex, toIndex);\n  let size = state.beforeSize || 0;\n  size = pageNumKeys.reduce((total, pageKey) => (\n    total += state.pageSizes[pageKey] || 0\n  ), size);\n  size += state.afterSize || 0;\n  return size;\n};\n\nconst isPageInViewport = (page, axis, state, scrollView) => {\n  if (!scrollView) {\n    return false;\n  }\n  const id = numToId(page);\n  const el = scrollView.querySelector(`[data-page=\"${id}\"]`);\n  return isElementInViewport({ el, axis });\n};\n\nconst updatePageSize = state => (pageId, size) => (\n  state.pageSizes[pageId] = size,\n  state.sortedKeys = Object.keys(state.pageSizes).sort()\n);\n\nconst handleScroll = (state, view, action) => {\n  const scroll = () => {\n    state.isScrolling = true;\n    // reset isScrolling state only when scrolling is done\n    clearTimeout(state.scrollWatchScrollingStateId);\n    state.scrollWatchScrollingStateId = setTimeout(() => {\n      state.isScrolling = false;\n      // update pages\n      m.redraw();\n    }, state.scrollThrottle);\n    // throttle updates while scrolling\n    if (!state.scrollWatchUpdateStateId) {\n      state.scrollWatchUpdateStateId = setTimeout(() => {\n        // update pages\n        m.redraw();\n        state.scrollWatchUpdateStateId = null;\n      }, state.scrollThrottle);\n    }\n  };\n  if (action === \"add\") {\n    view.addEventListener(\"scroll\", scroll);\n  } else {\n    view.removeEventListener(\"scroll\", scroll);\n  }\n};\n\nconst updatePart = (dom, whichSize, state, axis) => {\n  const size = getElementSize(dom, axis);\n  if (size) {\n    state[whichSize] = size;\n  }\n};\n\nconst getPageList = (currentPageNum, fromPage, toPage, currentPage, preloadSlots, maxPages) => {\n  const minPageNum = fromPage\n    ? parseInt(fromPage, 10)\n    : currentPage\n      ? currentPage\n      : 1;\n  const maxPageNum = toPage\n    ? parseInt(toPage, 10)\n    : currentPage\n      ? currentPage\n      : maxPages;\n  const pages = [];\n  const prePages = [];\n  for (let i = -preloadSlots; i <= preloadSlots; i = i + 1) {\n    const pageNum = currentPageNum + i;\n    if (pageNum >= minPageNum && pageNum <= maxPageNum) {\n      pages.push(pageNum);\n    }\n  }\n  for (let pageNum = 1; pageNum < pages[0]; pageNum = pageNum + 1) {\n    prePages.push(pageNum);\n  }\n  return {pages, prePages, maxPageNum};\n};\n\nconst oninit = vnode => {\n  const attrs = vnode.attrs;\n  // Memoize some properties that do not change\n  const axis = attrs.axis || \"y\";\n  const whichScroll = axis === \"x\" ? \"scrollLeft\" : \"scrollTop\";\n  const autoSize = (attrs.autoSize !== undefined && attrs.autoSize === false) ? false : true;\n  const pageSize = attrs.pageSize;\n  const scrollThrottle = attrs.throttle !== undefined ? attrs.throttle * 1000 : SCROLL_WATCH_TIMER;\n  const contentTag = attrs.contentTag || \"div\";\n  const classList = [\n    classes.scrollView,\n    axis === \"x\"\n      ? classes.scrollViewX\n      : classes.scrollViewY,\n    attrs.class\n  ].join(\" \");\n\n  vnode.state = Object.assign(\n    {},\n    {\n      pageSizes: {},\n      sortedKeys: [],\n      beforeSize: null,\n      afterSize: null,\n      scrollView: null,\n      isScrolling: false,\n      scrollWatchScrollingStateId: null,\n      scrollWatchUpdateStateId: null,\n      preloadSlots: attrs.preloadPages || 1,\n      boundingClientRect: {},\n      currentPageNum: 0,\n      scrollAmount: 0,\n\n      // Memoized\n      classList,\n      axis,\n      whichScroll,\n      autoSize,\n      pageSize,\n      scrollThrottle,\n      contentTag\n    }\n  );\n};\n\nconst view = ({state, attrs}) => {\n  state.scrollAmount = state.scrollView ? state.scrollView[state.whichScroll] : 0;\n  const axis = state.axis;\n  const maxPages = attrs.maxPages !== undefined ? attrs.maxPages : Number.MAX_VALUE;\n\n  const currentPageNum = attrs.currentPage\n    ? parseInt(attrs.currentPage, 10)\n    : calculateCurrentPageNum(state.scrollAmount, state);\n\n  if (attrs.pageChange && currentPageNum !== state.currentPageNum) {\n    attrs.pageChange(currentPageNum);\n  }\n  state.currentPageNum = currentPageNum;\n\n  if (state.scrollView && attrs.getDimensions) {\n    attrs.getDimensions({\n      scrolled: state.scrollAmount,\n      size: state.contentSize\n    });\n  }\n\n  const {pages, prePages, maxPageNum} = getPageList(currentPageNum, attrs.from, attrs.to, attrs.currentPage, state.preloadSlots, maxPages);\n\n  state.contentSize = calculateContentSize(1, maxPageNum, state);\n  const isLastPageVisible = maxPageNum\n    ? isPageInViewport(maxPageNum, axis, state, state.scrollView)\n    : true;\n\n  if (state.scrollView) {\n    // in case the screen size was changed, reset preloadSlots\n    const boundingClientRect = state.scrollView.getBoundingClientRect();\n    state.boundingClientRect = state.boundingClientRect || boundingClientRect;\n    if (boundingClientRect.width !== state.boundingClientRect.width\n      || boundingClientRect.height !== state.boundingClientRect.height\n    ) {\n      state.preloadSlots = attrs.preloadPages || 1;\n    }\n    state.boundingClientRect = boundingClientRect;\n    // calculate if we have room to load more\n    const maxSlots = attrs.maxPreloadPages || Number.MAX_VALUE;\n\n    if (state.contentSize\n      && (state.preloadSlots < pages.length)\n      && (state.preloadSlots <= maxSlots)\n      && (state.contentSize < boundingClientRect.height)\n    ) {\n      state.preloadSlots++;\n      setTimeout(m.redraw, 0);\n    }\n  }\n\n  return m(\"div\",\n    {\n      oncreate: ({ dom }) => {\n        state.scrollView = attrs.scrollView\n          ? document.querySelector(attrs.scrollView)\n          : dom;\n        state.scrollView.className += \" \" + state.classList;\n\n        if (attrs.setDimensions) {\n          const dimensions = attrs.setDimensions();\n          if (dimensions.size > 0) {\n            const whichSize = axis === \"x\"\n              ? \"width\"\n              : \"height\";\n            dom.style[whichSize] = dimensions.size + \"px\";\n          }\n          state.scrollView[state.whichScroll] = dimensions.scrolled;\n        }\n        handleScroll(state, state.scrollView, \"add\");\n      },\n      onremove: () => handleScroll(state, state.scrollView, \"remove\")\n    },\n    m(\"div\",\n      {\n        class: classes.scrollContent,\n        style: !state.autoSize\n          ? null\n          : Object.assign(\n            {},\n            axis === \"x\"\n              ? { width: state.contentSize + \"px\" }\n              : { height: state.contentSize + \"px\" },\n            attrs.contentSize\n              ? axis === \"x\"\n                ? { \"min-width\": attrs.contentSize + \"px\" }\n                : { \"min-height\": attrs.contentSize + \"px\" }\n              : {}\n        )\n      },\n      [\n        m(state.contentTag, { class: classes.content }, [\n          attrs.before\n            ? m(\"div\", {\n              class: classes.before,\n              oncreate: ({ dom }) => updatePart(dom, \"before\", state, axis),\n              onupdate: ({ dom }) => updatePart(dom, \"before\", state, axis)\n            }, attrs.before)\n            : null,\n          m(\"div\", { class: classes.pages }, [\n            prePages.map(pageNum => \n              m(placeholder, Object.assign(\n                {},\n                {\n                  axis,\n                  key: numToId(pageNum),\n                  pageId: numToId(pageNum),\n                  pageNum,\n                  pageSizes: state.pageSizes\n                }\n              ))\n            ),\n            pages.map(pageNum =>\n              m(page, Object.assign(\n                {},\n                {\n                  autoSize: state.autoSize,\n                  axis,\n                  isScrolling: state.isScrolling,\n                  item: attrs.item,\n                  key: numToId(pageNum),\n                  pageData: attrs.pageData,\n                  pageId: numToId(pageNum),\n                  pageNum,\n                  pageSize: state.pageSize,\n                  pageSizes: state.pageSizes,\n                  pageTag: attrs.pageTag,\n                  pageUrl: attrs.pageUrl,\n                  updatePageSize: updatePageSize(state)\n                }\n              ))\n            )\n          ]),\n          // only show \"after\" when content is available\n          attrs.after && state.contentSize\n            ? m(\"div\", {\n              class: classes.after,\n              style: {\n                // visually hide this element until the last page is into view\n                // to prevent flashes of after content when scrolling fast\n                visibility: isLastPageVisible ? \"visible\" : \"hidden\"\n              },\n              oncreate: ({ dom }) => updatePart(dom, \"after\", state, axis),\n              onupdate: ({ dom }) => updatePart(dom, \"after\", state, axis),\n            }, attrs.after)\n            : null\n        ])\n      ]\n    )\n  );\n};\n\nexport const infinite = {\n  oninit,\n  view,\n  isElementInViewport\n};\n\n"],"names":["classes","LEEWAY","getElementSize","el","axis","styles","window","getComputedStyle","margin","parseFloat","marginLeft","marginRight","scrollWidth","marginTop","marginBottom","scrollHeight","isElementInViewport","leeway","verge","inY","inX","inViewport","makeClassName","page","pageNum","pageEven","pageOdd","join","createStream","stream","arguments","length","HALT","updateStream","_state","value","initStream","constructor","id","guid","undefined","state","derive","recover","deps","parents","endStream","map","ap","valueOf","toJSON","toString","defineProperties","get","unregisterStream","finalize","updateState","changed","updateDependency","mustSync","every","active","some","combine","fn","streams","valid","Error","initDependency","apply","this","concat","filter","dep","notEnded","registerDependency","i","parent","dependent","index","indexOf","splice","s1","s2","merge","s","require$$0","getPageData","m","request","oninit","attrs","content","prop","pageData","result","then","pageUrl","url","processPageData","attrs1","data","item","className","pageTag","view","pageId","storedPageSize","pageSizes","pageSize","updatePageSize","cssSize","autoSize","isScrolling","update","size","dom","redraw","width","height","placeholder","vnode","babelHelpers.extends","j2c","J2c","addStyle","styleEl","document","createElement","setAttribute","forEach","styleList","Object","keys","style","scoped","@global","sheet","appendChild","createTextNode","head","removeStyle","old","getElementById","parentNode","removeChild","scrollView","scrollViewY","scrollContent","scrollViewX","SCROLL_WATCH_TIMER","SEL_PADDING","numToId","substring","calculateCurrentPageNum","scrollAmount","pageNumKeys","sortedKeys","acc","beforeSize","currentPageNum","pageKey","parseInt","calculateContentSize","from","to","fromIndex","Math","max","toIndex","slice","reduce","total","afterSize","isPageInViewport","querySelector","sort","handleScroll","action","scroll","scrollWatchScrollingStateId","setTimeout","scrollThrottle","scrollWatchUpdateStateId","addEventListener","removeEventListener","updatePart","whichSize","getPageList","fromPage","toPage","currentPage","preloadSlots","maxPages","minPageNum","maxPageNum","pages","prePages","push","whichScroll","throttle","contentTag","classList","class","preloadPages","Number","MAX_VALUE","pageChange","getDimensions","contentSize","isLastPageVisible","boundingClientRect","getBoundingClientRect","maxSlots","maxPreloadPages","setDimensions","dimensions","scrolled","min-width","min-height","before","after","infinite"],"mappings":"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"}